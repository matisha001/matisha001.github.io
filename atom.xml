<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>matisha&#39;s Notes</title>
  
  <subtitle>随记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://matisha001.github.io/"/>
  <updated>2017-10-05T19:59:13.649Z</updated>
  <id>https://matisha001.github.io/</id>
  
  <author>
    <name>仰天長嘯歸去來，金戈鐵馬功壹場！</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vuex2.x</title>
    <link href="https://matisha001.github.io/2016/10/23/vuex2.x/"/>
    <id>https://matisha001.github.io/2016/10/23/vuex2.x/</id>
    <published>2016-10-22T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.649Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://note.youdao.com/yws/res/17461/CEBC22DFECD4431B90CE2C5E45DBD418" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/17461/CEBC22DFECD4431B90CE2C5E45DBD418&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
      <category term="frame" scheme="https://matisha001.github.io/tags/frame/"/>
    
      <category term="vue" scheme="https://matisha001.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="https://matisha001.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>vuex1.x</title>
    <link href="https://matisha001.github.io/2016/10/23/vuex1.x/"/>
    <id>https://matisha001.github.io/2016/10/23/vuex1.x/</id>
    <published>2016-10-22T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.647Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://note.youdao.com/yws/res/3115/86270F4770EC4CAABB853748B0372E0F" alt="image"></p><ul><li>第1步：加入 store</li><li>第2步：创建 action</li><li>第3步：创建 state 和 mutation</li><li>第4步：在组件获取值</li></ul><p>State 和 Getters</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/3115/86270F4770EC4CAABB853748B0372E0F&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1步：加入 store&lt;/li&gt;
&lt;li&gt;第2步：创建 ac
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
      <category term="frame" scheme="https://matisha001.github.io/tags/frame/"/>
    
      <category term="vue" scheme="https://matisha001.github.io/tags/vue/"/>
    
      <category term="vuex" scheme="https://matisha001.github.io/tags/vuex/"/>
    
  </entry>
  
  <entry>
    <title>vue2.x指令</title>
    <link href="https://matisha001.github.io/2016/10/22/vue2.x%E6%8C%87%E4%BB%A4/"/>
    <id>https://matisha001.github.io/2016/10/22/vue2.x指令/</id>
    <published>2016-10-21T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h2><p>v-model v-for v-if v-show v-else v-on v-once v-html v-bind v-on</p><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><h3 id="自定义全局指令"><a href="#自定义全局指令" class="headerlink" title="自定义全局指令"></a>自定义全局指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 注册一个全局自定义指令 v-focus</div><div class="line">Vue.directive(&apos;focus&apos;, &#123;</div><div class="line">  // 当绑定元素插入到 DOM 中。</div><div class="line">  inserted: function (el) &#123;</div><div class="line">    // 聚焦元素</div><div class="line">    el.focus()</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><a id="more"></a><h3 id="自定义局部指令"><a href="#自定义局部指令" class="headerlink" title="自定义局部指令"></a>自定义局部指令</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">directives: &#123;</div><div class="line">  focus: &#123;</div><div class="line">    <span class="comment">// 指令的定义---</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">&lt;input v-focus&gt;</div></pre></td></tr></table></figure><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作</p><p>inserted: 被绑定元素插入父节点时调用</p><p>update: 所在组件的 VNode 更新时调用</p><p>componentUpdated: 所在组件的 VNode 及其孩子的 VNode 全部更新时调用</p><p>unbind: 只调用一次， 指令与元素解绑时调用</p><h3 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h3><p>钩子函数被赋予了以下参数：</p><ul><li>el: 指令所绑定的元素，可以用来直接操作 DOM 。</li><li>binding: 一个对象，包含以下属性：<ul><li>name: 指令名，不包括 v- 前缀。</li><li>value: 指令的绑定值。</li><li>oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。</li><li>expression: 绑定值的字符串形式。</li><li>arg: 传给指令的参数。</li><li>modifiers: 一个包含修饰符的对象。</li></ul></li><li>vnode: Vue 编译生成的虚拟节点</li><li>oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Vue.directive(&apos;demo&apos;, &#123;</div><div class="line">  bind: function (el, binding, vnode) &#123;</div><div class="line">    var s = JSON.stringify</div><div class="line">    el.innerHTML =</div><div class="line">      &apos;name: &apos;       + s(binding.name) + &apos;&lt;br&gt;&apos; +</div><div class="line">      &apos;value: &apos;      + s(binding.value) + &apos;&lt;br&gt;&apos; +</div><div class="line">      &apos;expression: &apos; + s(binding.expression) + &apos;&lt;br&gt;&apos; +</div><div class="line">      &apos;argument: &apos;   + s(binding.arg) + &apos;&lt;br&gt;&apos; +</div><div class="line">      &apos;modifiers: &apos;  + s(binding.modifiers) + &apos;&lt;br&gt;&apos; +</div><div class="line">      &apos;vnode keys: &apos; + Object.keys(vnode).join(&apos;, &apos;)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">new Vue(&#123;</div><div class="line">  el: &apos;#hook-arguments-example&apos;,</div><div class="line">  data: &#123;</div><div class="line">    message: &apos;hello!&apos;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>简写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.directive(<span class="string">'color-swatch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</div><div class="line">  el.style.backgroundColor = binding.value</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-demo</span>=<span class="string">"&#123; color: 'white', text: 'hello!' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">Vue.directive('demo', function (el, binding) &#123;</div><div class="line">  console.log(binding.value.color) // =&gt; "white"</div><div class="line">  console.log(binding.value.text)  // =&gt; "hello!"</div><div class="line">&#125;)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;内置指令&quot;&gt;&lt;a href=&quot;#内置指令&quot; class=&quot;headerlink&quot; title=&quot;内置指令&quot;&gt;&lt;/a&gt;内置指令&lt;/h2&gt;&lt;p&gt;v-model v-for v-if v-show v-else v-on v-once v-html v-bind v-on&lt;/p&gt;
&lt;h2 id=&quot;自定义指令&quot;&gt;&lt;a href=&quot;#自定义指令&quot; class=&quot;headerlink&quot; title=&quot;自定义指令&quot;&gt;&lt;/a&gt;自定义指令&lt;/h2&gt;&lt;h3 id=&quot;自定义全局指令&quot;&gt;&lt;a href=&quot;#自定义全局指令&quot; class=&quot;headerlink&quot; title=&quot;自定义全局指令&quot;&gt;&lt;/a&gt;自定义全局指令&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// 注册一个全局自定义指令 v-focus&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Vue.directive(&amp;apos;focus&amp;apos;, &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  // 当绑定元素插入到 DOM 中。&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  inserted: function (el) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    // 聚焦元素&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    el.focus()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
      <category term="frame" scheme="https://matisha001.github.io/tags/frame/"/>
    
      <category term="vue" scheme="https://matisha001.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue-router2.x</title>
    <link href="https://matisha001.github.io/2016/10/21/vue-router2.x/"/>
    <id>https://matisha001.github.io/2016/10/21/vue-router2.x/</id>
    <published>2016-10-20T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.629Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><p>在vue-router2.x中使用v-link 指令已经被 <router-link> 组件替代。</router-link></p><p><img src="http://note.youdao.com/yws/res/2946/C5AC7BFABBE54BEC9C6F9C1FD299422B" alt="image"></p><p>当 <router-link> 对应的路由匹配成功，将自动设置 class 属性值 .router-link-active。</router-link></p><p><img src="http://note.youdao.com/yws/res/2965/6274DED77A5E4A038FA14442CE4C7CAC" alt="image"></p><p><img src="http://note.youdao.com/yws/res/2968/B28F389F5C8E47DA894D78726D9FB3B5" alt="image"></p><p><img src="http://note.youdao.com/yws/res/2970/A9FBED3A15764655951E550A4755FF6A" alt="image"></p><p><img src="http://note.youdao.com/yws/res/2972/D6A0EBE67F0C44328387C55A40AF43E3" alt="image"></p><h3 id="动态路由的匹配"><a href="#动态路由的匹配" class="headerlink" title="动态路由的匹配"></a>动态路由的匹配</h3><p><img src="http://note.youdao.com/yws/res/2977/1D37DB31749540C2B2E0398B33CF8364" alt="image"></p><p><img src="http://note.youdao.com/yws/res/2982/F2F4A6F449824E4EBC7AD746C50349DB" alt="image"></p><p><img src="http://note.youdao.com/yws/res/2981/85F978ED29E1434AB670111378ACC191" alt="image"></p><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p><img src="http://note.youdao.com/yws/res/2985/B43AD070CBD649E28BA1BBB52C49FDCE" alt="image"></p><p><img src="http://note.youdao.com/yws/res/2988/33729C1EBC4B4B54856938C0E3953557" alt="image"></p><blockquote><p>在vue-rouer0.7x中，子路由用subRoutes。</p></blockquote><h3 id="编程式的导航"><a href="#编程式的导航" class="headerlink" title="编程式的导航"></a>编程式的导航</h3><p> router.push(location)</p><p> <img src="http://note.youdao.com/yws/res/2995/6083B85E020F48B68E8D64075C4ECCDC" alt="image"></p><p> <img src="http://note.youdao.com/yws/res/2997/A51384F60CBA4F91B5826F60C9C9A4B6" alt="image"></p><p> router.replace(location)</p><p> <img src="http://note.youdao.com/yws/res/3002/1698F38B082A411B9297F1C1B8BFC4C7" alt="image"></p><p> <img src="http://note.youdao.com/yws/res/3004/895C265CDAA042839CD0AB8591AE57F1" alt="image"></p><p> <img src="http://note.youdao.com/yws/res/3008/C9C38B563407464FB7230D9871A595EB" alt="image"></p><h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p><img src="http://note.youdao.com/yws/res/3013/C8762E3BE8B14513ABB9EE2C0B3DC5FD" alt="image"></p><p><img src="http://note.youdao.com/yws/res/3015/7165CFF4B76A44A8954CF6F3A3AED763" alt="image"></p><p><img src="http://note.youdao.com/yws/res/3017/385294F604A744BF8FBC155EE9D97162" alt="image"></p><h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><p><img src="http://note.youdao.com/yws/res/3022/5AA4BAB9EBD7420EB2FF7F43C82D66D2" alt="image"></p><p><img src="http://note.youdao.com/yws/res/3024/0FA2DADB5C294E70A31DE5A657CC4874" alt="image"></p><p><img src="http://note.youdao.com/yws/res/3026/F69A299302CC45A6A7833C2AFA8DF39C" alt="image"></p><p><img src="http://note.youdao.com/yws/res/3028/5C6B8C56EA7645EEB582B3CBFC771F7C" alt="image"></p><h3 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h3><p><img src="http://note.youdao.com/yws/res/3033/6780F81C4551452FB79B8EEB7492A0B5" alt="image"></p><p><img src="http://note.youdao.com/yws/res/3035/6FA4FA88243A4F48B6CBAF7C20CE6E0C" alt="image"></p><h3 id="HTML5-History-模式"><a href="#HTML5-History-模式" class="headerlink" title="HTML5 History 模式"></a>HTML5 History 模式</h3><p><img src="http://note.youdao.com/yws/res/3038/7E34CB88E6FE4E5581E6A5E3696F1629" alt="image"></p><h3 id="全局钩子"><a href="#全局钩子" class="headerlink" title="全局钩子"></a>全局钩子</h3><p><img src="http://note.youdao.com/yws/res/3041/B57C389FA54E4A079B44687AB544F49E" alt="image"></p><h3 id="某个路由独享的钩子"><a href="#某个路由独享的钩子" class="headerlink" title="某个路由独享的钩子"></a>某个路由独享的钩子</h3><p><img src="http://note.youdao.com/yws/res/3044/E5E1D442454041DE811778D38CD9ACCF" alt="image"></p><p><img src="http://note.youdao.com/yws/res/3046/21B3A8718F1542E58729C057D07C9C4B" alt="image"></p><h3 id="组件内的钩子"><a href="#组件内的钩子" class="headerlink" title="组件内的钩子"></a>组件内的钩子</h3><p><img src="http://note.youdao.com/yws/res/3051/E55E20AF7A1D40E6A002F48E2A1E97B3" alt="image"></p><ul><li>使用组件自身的生命周期钩子函数来替代activate 和 deactivate</li><li>在$router 上使用 watcher 来响应路由改变 (e.g. 比如基于新的路由参数获取数据)</li><li>canActivate 可以被router 的配置中的 beforeEnter 中实现。</li><li>canDeactivate 已经被 beforeRouteLeave 取代, 后者在一个组件的根级定义中指定。这个钩子函数在调用时是将组件的实例作为其上下文的。</li><li>canReuse 已经被移除，因其容易混淆且很少被用到。</li></ul><h3 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h3><p><img src="http://note.youdao.com/yws/res/3057/D342AD7A23E34711ACD7A559323FF0FB" alt="image"></p><p><img src="http://note.youdao.com/yws/res/3059/D46D4D6FBFF74F4D83291CF7FD3ED97C" alt="image"></p><h3 id="过渡特效"><a href="#过渡特效" class="headerlink" title="过渡特效"></a>过渡特效</h3><p><img src="http://note.youdao.com/yws/res/3064/069ED312D7E24B16A13FE853DD21A40D" alt="image"></p><p><img src="http://note.youdao.com/yws/res/3067/4E669B9DC36B4DE98812361799E1028F" alt="image"></p><h3 id="滚动行为"><a href="#滚动行为" class="headerlink" title="滚动行为"></a>滚动行为</h3><p><img src="http://note.youdao.com/yws/res/3071/94906A03CA0B475B848818139F2B4676" alt="image"></p><p><img src="http://note.youdao.com/yws/res/3073/33CBC4A3E54F421FBE3D96612F58F996" alt="image"></p><p>路由信息对象</p><p><img src="http://note.youdao.com/yws/res/3077/9BC1FECBB8AD42788E302776BF7328D7" alt="image"></p><p><img src="http://note.youdao.com/yws/res/3079/CCC143565CF64714B159E43DE2BE15FB" alt="image"></p><p><img src="http://note.youdao.com/yws/res/3081/5E64CA0F992D44348977E9EBB4E24960" alt="image"></p><p>Router_构造配置<br><img src="http://note.youdao.com/yws/res/3085/A7A753BF820A4CDEB4888C9AC991B7AE" alt="image"></p><p><img src="http://note.youdao.com/yws/res/3088/DECAA8A466754677B706DA23E1B710A4" alt="image"></p><p><img src="http://note.youdao.com/yws/res/3090/CB92B55532014DFAB4746B7DD203C88C" alt="image"></p><h3 id="Router-实例"><a href="#Router-实例" class="headerlink" title="Router_实例"></a>Router_实例</h3><p><img src="http://note.youdao.com/yws/res/3097/A734474E1E9D40C492CE9EB92BD84A7A" alt="image"></p><h3 id="对组件注入"><a href="#对组件注入" class="headerlink" title="对组件注入"></a>对组件注入</h3><p><img src="http://note.youdao.com/yws/res/3102/74F0496BBFF746DA9E226410E58A0F22" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本写法&quot;&gt;&lt;a href=&quot;#基本写法&quot; class=&quot;headerlink&quot; title=&quot;基本写法&quot;&gt;&lt;/a&gt;基本写法&lt;/h3&gt;&lt;p&gt;在vue-router2.x中使用v-link 指令已经被 &lt;router-link&gt; 组件替代。&lt;/router-link
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
      <category term="frame" scheme="https://matisha001.github.io/tags/frame/"/>
    
      <category term="vue" scheme="https://matisha001.github.io/tags/vue/"/>
    
      <category term="vue-router" scheme="https://matisha001.github.io/tags/vue-router/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的工作原理</title>
    <link href="https://matisha001.github.io/2016/10/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://matisha001.github.io/2016/10/20/浏览器的工作原理/</id>
    <published>2016-10-19T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.653Z</updated>
    
    <content type="html"><![CDATA[<p>新式网络浏览器幕后揭秘</p><blockquote><p><a href="http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork" target="_blank" rel="external">http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork</a></p></blockquote><a id="more"></a><p>浏览器的工作原理</p><blockquote><p><a href="http://www.w3ctech.com/topic/48" target="_blank" rel="external">http://www.w3ctech.com/topic/48</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新式网络浏览器幕后揭秘&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>vue2.x事件</title>
    <link href="https://matisha001.github.io/2016/09/30/vue2.x%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <id>https://matisha001.github.io/2016/09/30/vue2.x事件与数据绑定/</id>
    <published>2016-09-29T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>使用 v-on 绑定自定义事件</p><ul><li>使用 $on(eventName) 监听事件</li><li>使用 $emit(eventName) 触发事件</li></ul><blockquote><p>父组件可以在使用子组件的地方直接用v-on来监听子组件触发的事件</p><p>不能用 $on 侦听子组件释放的事件，而必须在模板里直接用 v-on 绑定</p><p>可以使用 .native修饰v-on，在某个组件的根元素上监听一个原生事件</p></blockquote><a id="more"></a><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><h3 id="子组件改变父组件"><a href="#子组件改变父组件" class="headerlink" title="子组件改变父组件"></a>子组件改变父组件</h3><blockquote><p>使用.sync 修饰符,当一个子组件改变了一个prop的值时，这个变化也会同步到父组件中所绑定的值。 (注意此处在 2.3.0版本以后)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;</div><div class="line">&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;</div><div class="line">更新事件 this.$emit(&apos;update:foo&apos;, newValue)</div></pre></td></tr></table></figure><h3 id="表单组件数据双向绑定"><a href="#表单组件数据双向绑定" class="headerlink" title="表单组件数据双向绑定"></a>表单组件数据双向绑定</h3><blockquote><p>自定义事件可以用来创建自定义的表单输入组件，使用 v-model 来进行数据双向绑定。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;input v-model=&quot;something&quot;&gt;</div><div class="line"></div><div class="line">(2.2.0版本 )</div><div class="line">&lt;my-checkbox v-model=&quot;foo&quot; value=&quot;some value&quot;&gt;&lt;/my-checkbox&gt;</div><div class="line"></div><div class="line"></div><div class="line">Vue.component(&apos;my-checkbox&apos;, &#123;</div><div class="line">  model: &#123;</div><div class="line">    prop: &apos;checked&apos;,</div><div class="line">    event: &apos;change&apos;</div><div class="line">  &#125;,</div><div class="line">  props: &#123;</div><div class="line">    checked: Boolean,</div><div class="line">    value: String</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">&#125;)</div><div class="line"></div><div class="line">等价形式</div><div class="line">&lt;my-checkbox</div><div class="line">  :checked=&quot;foo&quot;</div><div class="line">  @change=&quot;val =&gt; &#123; foo = val &#125;&quot;</div><div class="line">  value=&quot;some value&quot;&gt;</div><div class="line">&lt;/my-checkbox&gt;</div></pre></td></tr></table></figure><p>v-model</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;事件&quot;&gt;&lt;a href=&quot;#事件&quot; class=&quot;headerlink&quot; title=&quot;事件&quot;&gt;&lt;/a&gt;事件&lt;/h2&gt;&lt;h3 id=&quot;自定义事件&quot;&gt;&lt;a href=&quot;#自定义事件&quot; class=&quot;headerlink&quot; title=&quot;自定义事件&quot;&gt;&lt;/a&gt;自定义事件&lt;/h3&gt;&lt;p&gt;使用 v-on 绑定自定义事件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 $on(eventName) 监听事件&lt;/li&gt;
&lt;li&gt;使用 $emit(eventName) 触发事件&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;父组件可以在使用子组件的地方直接用v-on来监听子组件触发的事件&lt;/p&gt;
&lt;p&gt;不能用 $on 侦听子组件释放的事件，而必须在模板里直接用 v-on 绑定&lt;/p&gt;
&lt;p&gt;可以使用 .native修饰v-on，在某个组件的根元素上监听一个原生事件&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
      <category term="frame" scheme="https://matisha001.github.io/tags/frame/"/>
    
      <category term="vue" scheme="https://matisha001.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>react基础学习</title>
    <link href="https://matisha001.github.io/2016/09/29/react%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <id>https://matisha001.github.io/2016/09/29/react基础学习/</id>
    <published>2016-09-28T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.624Z</updated>
    
    <content type="html"><![CDATA[<h3 id="React-简介"><a href="#React-简介" class="headerlink" title="React 简介"></a>React 简介</h3><h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p>React起源于Facebook的内部项目，该公司积极尝试引入HTML5技术用来架设Instagram网站，开发中发现HTML5的性能下降明显，达不到预期的效果。他们就自己开发了React框架。</p><a id="more"></a><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><strong>虚拟DOM:</strong>  React也是以数据驱动的，每次数据变化React都会扫码整个虚拟DOM树，自动计算与上次虚拟DOM的差异变化，然后针对需要变化的部分进行实际的浏览器DOM更新。<br><strong>组件化:</strong>  React可以从功能角度横向划分，将UI分解成不同组件，各组件都独立封装，整个UI是由一个个小组件构成的一个大组件，每个组件只关系自身的逻辑，彼此独立。<br><strong>单项数据流:</strong> React设计者认为数据双向绑定虽然便捷，但在复杂场景下副作用也是很明显，所以React更倾向于单向的数据流动-从父节点传递到子节点。（使用ReactLink也可以实现双向绑定，但不建议使用）</p><h3 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h3><h4 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h4><p>ReactJS官方地址：<a href="https://facebook.github.io/react/" target="_blank" rel="external">https://facebook.github.io/react/</a></p><p>GitHub地址：<a href="https://github.com/facebook/react" target="_blank" rel="external">https://github.com/facebook/react</a></p><p>引用react.js和react-dom.js（注意引用顺序）</p><p><strong>react.js：</strong> 实现React核心逻辑，且于具体的渲染引擎无关，从而可以跨平台公用。如果应用要迁移到React Native，这一部分逻辑是不需要改变的。<br><strong>react-dom.js：</strong>  包含了具体的DOM渲染更新逻辑，以及服务端渲染的逻辑，这部分就是与浏览器相关的部分了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"./common/react.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">&lt;script src=<span class="string">"./common/react-dom.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"reactContainer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    <span class="keyword">var</span> HelloComponent = React.createClass(&#123;</div><div class="line">        render:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> React.createElement(<span class="string">'h1'</span>, <span class="literal">null</span>, <span class="string">'Hello world'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    ReactDOM.render(</div><div class="line">        React.createElement(HelloComponent, <span class="literal">null</span>),</div><div class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'reactContainer'</span>)</div><div class="line">    );</div><div class="line">&lt;<span class="regexp">/script&gt;</span></div></pre></td></tr></table></figure><h4 id="React-createClass"><a href="#React-createClass" class="headerlink" title="React.createClass"></a>React.createClass</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;React-简介&quot;&gt;&lt;a href=&quot;#React-简介&quot; class=&quot;headerlink&quot; title=&quot;React 简介&quot;&gt;&lt;/a&gt;React 简介&lt;/h3&gt;&lt;h4 id=&quot;起源&quot;&gt;&lt;a href=&quot;#起源&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h4&gt;&lt;p&gt;React起源于Facebook的内部项目，该公司积极尝试引入HTML5技术用来架设Instagram网站，开发中发现HTML5的性能下降明显，达不到预期的效果。他们就自己开发了React框架。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
      <category term="react" scheme="https://matisha001.github.io/tags/react/"/>
    
      <category term="frame" scheme="https://matisha001.github.io/tags/frame/"/>
    
  </entry>
  
  <entry>
    <title>vue2.x组件</title>
    <link href="https://matisha001.github.io/2016/09/29/vue2.x%E7%BB%84%E4%BB%B6/"/>
    <id>https://matisha001.github.io/2016/09/29/vue2.x组件/</id>
    <published>2016-09-28T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h2><h3 id="组件的注册"><a href="#组件的注册" class="headerlink" title="组件的注册"></a>组件的注册</h3><p><img src="http://note.youdao.com/yws/res/1093/2EF21FDCC850470488F9EE6F087E3C5D" alt="image"></p><hr><h3 id="DOM模板解析"><a href="#DOM模板解析" class="headerlink" title="DOM模板解析"></a>DOM模板解析</h3><blockquote><p>Vue 只有在浏览器解析和标准化 HTML 后才能获取模版内容。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt; ， &lt;ol&gt;， &lt;table&gt; ， &lt;select&gt; 限制了能被它包裹的元素， &lt;option&gt; 只能出现在其它元素内部。在自定义组件中使用这些受限制的元素时会导致一些问题。</div></pre></td></tr></table></figure><p><img src="http://note.youdao.com/yws/res/1098/CDB1FD29C22A4F5E8C6EEAF662DF8CAA" alt="image"></p><p>自定义组件 <my-row>被认为是无效的内容，因此在渲染的时候会导致错误。变通的方案是使用特殊的 is 属性。</my-row></p><a id="more"></a><blockquote><p>如果您使用来自以下来源之一的字符串模板，这些限制将不适用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/x-template&quot;&gt;</div><div class="line">JavaScript 内联模版字符串</div><div class="line">.vue 组件</div></pre></td></tr></table></figure></p></blockquote><hr><h3 id="data-必须是函数"><a href="#data-必须是函数" class="headerlink" title="data-必须是函数"></a>data-必须是函数</h3><blockquote><p>通过 Vue 构造器传入的各种选项大多数都可以在组件里用。data 是一个例外，它必须是函数</p></blockquote><hr><h3 id="组件命名"><a href="#组件命名" class="headerlink" title="组件命名"></a>组件命名</h3><p><img src="http://note.youdao.com/yws/res/16573/D6ADCF52A5E4453C8E545A08246CDDC2" alt="image"></p><p>组件未经 slot 元素传递内容，你甚至可以在组件名后使用 / 使其自闭合</p><hr><h3 id="可复用组件"><a href="#可复用组件" class="headerlink" title="可复用组件"></a>可复用组件</h3><p>可复用的组件的API 来自三部分—— props , events ,和 slots </p><ol><li>Props 允许外部环境传递数据给组件</li><li>Events 允许组件触发外部环境的副作用</li><li>Slots 允许外部环境将额外的内容组合在组件中。</li></ol><p>推荐使用slot内容分发的具名slot与作用域插槽具名slot主要用于移动端的header组件，作用域插槽主要用于列表类组件</p><h2 id="Slot-分发内容"><a href="#Slot-分发内容" class="headerlink" title="Slot 分发内容"></a>Slot 分发内容</h2><p>分发内容是在父作用域内编译</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">child-component</span>&gt;</span></div><div class="line">  &#123;&#123; message &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></div><div class="line">message 应该绑定到父组件的数据</div></pre></td></tr></table></figure><p>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">试图在父组件模板内将一个指令绑定到子组件的属性/方法</div><div class="line">&lt;!-- 无效 --&gt;</div><div class="line">&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt;</div><div class="line">如果someChildProperty是子组件的属性。父组件模板不应该知道子组件的状态,要绑定作用域内的指令到对应子组件的根节点</div></pre></td></tr></table></figure><h3 id="单个slot"><a href="#单个slot" class="headerlink" title="单个slot"></a>单个slot</h3><blockquote><p>除非子组件模板包含至少一个<slot>插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。</slot></p></blockquote><p>在 <slot> 标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。<br><img src="http://note.youdao.com/yws/res/16570/A935FD2C3B95490CB206B14C0121A7D1" alt="image"></slot></p><h3 id="具名Slot"><a href="#具名Slot" class="headerlink" title="具名Slot"></a>具名Slot</h3><p><slot> 元素可以用一个特殊的属性 name 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 slot 特性的元素。<br><img src="http://note.youdao.com/yws/res/16569/6157D12F236B410C8A91A8F5FF44F1BD" alt="image"><br>仍然可以有一个匿名 slot ，它是默认 slot ，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot ，这些找不到匹配的内容片段将被抛弃。</slot></p><hr><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>作用域插槽是一种特殊类型的插槽，用作使用一个(能够传递数据到) 可重用模板替换已渲染元素。</p><blockquote><p>在父级中，具有特殊属性scope的<template>元素必须存在，表示它是作用域插槽的模板。scope的值对应一个临时变量名，此变量接收从子组件中传递的 props 对象</template></p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">子组件</div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"item"</span></span></div><div class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"item in items"</span></span></div><div class="line"><span class="tag">    <span class="attr">:text</span>=<span class="string">"item.text"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 这里写入备用内容 --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">父组件</div><div class="line"><span class="tag">&lt;<span class="name">my-awesome-list</span> <span class="attr">:items</span>=<span class="string">"items"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 作用域插槽也可以是具名的 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">"item"</span> <span class="attr">scope</span>=<span class="string">"props"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"my-fancy-item"</span>&gt;</span>&#123;&#123; props.text &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">my-awesome-list</span>&gt;</span></div></pre></td></tr></table></figure><hr><h2 id="各种组件"><a href="#各种组件" class="headerlink" title="各种组件"></a>各种组件</h2><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 <component> 元素，动态地绑定到它的 is特性。</component></p><p><img src="http://note.youdao.com/yws/res/16576/07C1B01FB7F4443CAF3A926A899F857B" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;</div></pre></td></tr></table></figure><h3 id="keep-alive组件存内存"><a href="#keep-alive组件存内存" class="headerlink" title="keep-alive组件存内存"></a>keep-alive组件存内存</h3><p>如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentView"</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 非活动组件将被缓存！ --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure><p><keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个DOM元素，也不会出现在父组件链中。当组件在 <keep-alive> 内被切换，它的 activated 和 deactivated这两个生命周期钩子函数将会被对应执行。主要用于保留组件状态或避免重新渲染。</keep-alive></keep-alive></transition></keep-alive></p><h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h3><p>组件在它的模板内可以递归地调用自己，不过，只有当它有 name 选项时才可以。</p><p><img src="http://note.youdao.com/yws/res/16577/59F673EB9EED4491BB161469ED35432D" alt="image"></p><h3 id="内联模版"><a href="#内联模版" class="headerlink" title="内联模版"></a>内联模版</h3><p>子组件有 inline-template特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。<br><img src="http://note.youdao.com/yws/res/16578/0AA408327CF847FA8D72E4D27DFBFE58" alt="image"></p><h3 id="X-Templates"><a href="#X-Templates" class="headerlink" title="X-Templates"></a>X-Templates</h3><p><img src="http://note.youdao.com/yws/res/16584/404EF58810D34B7FB18EBF69C94836BD" alt="image"></p><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。</p><p>工厂函数接收一个resolve回调，在收到从服务器下载的组件定义时调用。也可以调用 reject(reason) 指示加载失败。<br><img src="http://note.youdao.com/yws/res/16575/8AA6CC10291245E08ECE8BF448DA470D" alt="image"></p><p>2.3.0 新增</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">const AsyncComp = () =&gt; (&#123;</div><div class="line">  // 需要加载的组件. 应当是一个 Promise</div><div class="line">  component: import(&apos;./MyComp.vue&apos;),</div><div class="line">  // loading 时应当渲染的组件</div><div class="line">  loading: LoadingComp,</div><div class="line">  // 出错时渲染的组件</div><div class="line">  error: ErrorComp,</div><div class="line">  // 渲染 loading 组件前的等待时间。默认：200ms.</div><div class="line">  delay: 200,</div><div class="line">  // 最长等待时间。超出此时间则渲染 error 组件。默认：Infinity</div><div class="line">  timeout: 3000</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="v-once静态组件"><a href="#v-once静态组件" class="headerlink" title="v-once静态组件"></a>v-once静态组件</h3><p>当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来。</p><p><img src="http://note.youdao.com/yws/res/1337/6935344FE4DA42FDAB36EF4676D06D46" alt="image"></p><p>通过v-once指令，能够执行一次性的插值，但数据变化时，插值处的内容不会更新，可能会影响到该节点上的数据绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;span v-once&gt;&#123;&#123;message&#125;&#125;&lt;/span&gt;</div><div class="line">在vue1.x版本中禁止模板刷新数据使用的是</div><div class="line">&lt;span&gt;&#123;&#123;*message&#125;&#125;&lt;/span&gt;</div></pre></td></tr></table></figure><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">插入纯html代码以前用&#123;&#123;&#123;&#125;&#125;&#125;,现在用v-html</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"rawHtml"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="子组件索引"><a href="#子组件索引" class="headerlink" title="子组件索引"></a>子组件索引</h3><p>在 JavaScript 中直接访问子组件，可以使用ref为子组件指定一个索引 ID 。当ref和v-for一起使用时，ref是一个数组或对象，包含相应的子组件。<br><img src="http://note.youdao.com/yws/res/16586/771BD2C518724194AA4B2278A2B862DA" alt="image"></p><p>$refs 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 $refs 。</p><hr><h2 id="组件的通信"><a href="#组件的通信" class="headerlink" title="组件的通信"></a>组件的通信</h2><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><p>在 Vue 中，父子组件的关系可以总结为 props down, events up。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。<br><img src="http://note.youdao.com/yws/res/16574/CA896A5DFEC7458C8115DBCB1188D457" alt="image"></p><h4 id="父组件向子组件props传递数据"><a href="#父组件向子组件props传递数据" class="headerlink" title="父组件向子组件props传递数据"></a>父组件向子组件props传递数据</h4><blockquote><p>组件实例的作用域是孤立的,让子组件使用父组件的数据,需要通过子组件的 props 选项。</p></blockquote><p>prop 是父组件用来传递数据的一个自定义属性。子组件需要显式地用 props 选项 声明 “prop”。</p><p><img src="http://note.youdao.com/yws/res/16582/DF9C47262D6140E3B4D4243D65C4A2F0" alt="image"></p><p>HTML 特性不区分大小写。当使用非字符串模版时，名字形式为 camelCase 的 prop 用作特性时，需要转为 kebab-case（短横线隔开）。</p><p><img src="http://note.youdao.com/yws/res/16587/8A6DCC7A7C4F406F98CB4A81BF38D2DB" alt="image"></p><p>在模板中,用 v-bind。每当父组件的数据变化时，该变化也会传导给子组件</p><p><img src="http://note.youdao.com/yws/res/16588/EAB35643DF344DBCA6EC61D28F909E2B" alt="image"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 传递了一个字符串 "1" --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 传递实际的 number --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">v-bind:some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></div><div class="line">prop传递的为字符串</div><div class="line">使用 v-bind，让它的值被当作 JavaScript 表达式计算</div></pre></td></tr></table></figure><p><img src="http://note.youdao.com/yws/res/16580/86E69F361CC94853A89B44693BEECA66" alt="image"></p><ul><li><p>父组件的属性变化时，将传导给子组件,防止子组件无意修改了父组件的状态。每次父组件更新时，子组件的所有 prop 都会更新为最新值。</p></li><li><p>不应该在子组件内部改变 prop</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">定义一个局部变量，并用 prop 的值初始化它</div><div class="line">props: [&apos;initialCounter&apos;],</div><div class="line">data: function () &#123;</div><div class="line">  return &#123; counter: this.initialCounter &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">定义一个计算属性，处理 prop 的值并返回</div><div class="line">props: [&apos;size&apos;],</div><div class="line">computed: &#123;</div><div class="line">  normalizedSize: function () &#123;</div><div class="line">    return this.size</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>注意在 JavaScript中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。</p></blockquote><p>组件可以为 props指定验证要求。如果未指定验证要求，Vue会发出警告。props是一个对象而不是字符串数组时，它包含验证要求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;test&quot;&gt;</div><div class="line">    &lt;comp :prop-a=&quot;1&quot;  prop-b=&quot;1&quot;&gt;&lt;/comp&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">Vue.component(&apos;example&apos;, &#123;</div><div class="line">  props: &#123;</div><div class="line">    // 基础类型检测 (`null` 意思是任何类型都可以)</div><div class="line">    propA: Number,</div><div class="line">    propB: [String, Number],// 多种类型</div><div class="line">    propC: &#123;// 必传且是字符串</div><div class="line">      type: String,</div><div class="line">      required: true</div><div class="line">    &#125;,</div><div class="line">    propD: &#123;// 数字，有默认值</div><div class="line">      type: Number,</div><div class="line">      default: 100</div><div class="line">    &#125;,</div><div class="line">    propE: &#123;// 数组/对象的默认值应当由一个工厂函数返回</div><div class="line">      type: Object,</div><div class="line">      default: function () &#123;</div><div class="line">        return &#123; message: &apos;hello&apos; &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;,</div><div class="line">    propF: &#123;// 自定义验证函数</div><div class="line">      validator: function (value) &#123;</div><div class="line">        return value &gt; 10</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>type 可以是下面原生构造器:<br>String Number Boolean Function Object Array<br>type 也可以是一个自定义构造器，使用 instanceof 检测。</p><blockquote><p>当 prop 验证失败，Vue 会在抛出警告。注意 props 会在组件实例创建之前进行校验</p></blockquote><h4 id="父组件向子组件非props传递数据"><a href="#父组件向子组件非props传递数据" class="headerlink" title="父组件向子组件非props传递数据"></a>父组件向子组件非props传递数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">bs-date-input 的子组件模板</div><div class="line">&lt;input type=&quot;date&quot; class=&quot;form-control&quot;&gt;</div><div class="line">&lt;bs-date-input</div><div class="line">  data-3d-date-picker=&quot;true&quot;</div><div class="line">  class=&quot;date-picker-theme-dark&quot;</div><div class="line">&gt;&lt;/bs-date-input&gt;</div></pre></td></tr></table></figure><p>对于多数特性来说，传递给组件的值会覆盖组件本身设定的值。即例如传递 type=”large” 将会覆盖 type=”date” 且有可能破坏该组件！使用 class 和 style 特性的值都会做合并(merge)操作，让最终生成的值为：form-control date-picker-theme-dark。</p><h4 id="子组件向父组件传递数据"><a href="#子组件向父组件传递数据" class="headerlink" title="子组件向父组件传递数据"></a>子组件向父组件传递数据</h4><blockquote><p>使用.sync 修饰符,当一个子组件改变了一个prop的值时，这个变化也会同步到父组件中所绑定的值。 (注意此处在 2.3.0版本以后)</p></blockquote><h3 id="其他组件之间的通信"><a href="#其他组件之间的通信" class="headerlink" title="其他组件之间的通信"></a>其他组件之间的通信</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var bus = new Vue()</div><div class="line">// 触发组件 A 中的事件</div><div class="line">bus.$emit(&apos;id-selected&apos;, 1)</div><div class="line">// 在组件 B 创建的钩子中监听事件</div><div class="line">bus.$on(&apos;id-selected&apos;, function (id) &#123;</div><div class="line">  // ...</div><div class="line">&#125;)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;组件基础&quot;&gt;&lt;a href=&quot;#组件基础&quot; class=&quot;headerlink&quot; title=&quot;组件基础&quot;&gt;&lt;/a&gt;组件基础&lt;/h2&gt;&lt;h3 id=&quot;组件的注册&quot;&gt;&lt;a href=&quot;#组件的注册&quot; class=&quot;headerlink&quot; title=&quot;组件的注册&quot;&gt;&lt;/a&gt;组件的注册&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/1093/2EF21FDCC850470488F9EE6F087E3C5D&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;DOM模板解析&quot;&gt;&lt;a href=&quot;#DOM模板解析&quot; class=&quot;headerlink&quot; title=&quot;DOM模板解析&quot;&gt;&lt;/a&gt;DOM模板解析&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Vue 只有在浏览器解析和标准化 HTML 后才能获取模版内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;ul&amp;gt; ， &amp;lt;ol&amp;gt;， &amp;lt;table&amp;gt; ， &amp;lt;select&amp;gt; 限制了能被它包裹的元素， &amp;lt;option&amp;gt; 只能出现在其它元素内部。在自定义组件中使用这些受限制的元素时会导致一些问题。&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/1098/CDB1FD29C22A4F5E8C6EEAF662DF8CAA&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;自定义组件 &lt;my-row&gt;被认为是无效的内容，因此在渲染的时候会导致错误。变通的方案是使用特殊的 is 属性。&lt;/my-row&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
      <category term="frame" scheme="https://matisha001.github.io/tags/frame/"/>
    
      <category term="vue" scheme="https://matisha001.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>react生命周期</title>
    <link href="https://matisha001.github.io/2016/09/29/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://matisha001.github.io/2016/09/29/react生命周期/</id>
    <published>2016-09-28T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.627Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://note.youdao.com/yws/res/3364/66114E8FDCDB479FB0DE7AC6825712C2" alt="image"></p><a id="more"></a><p><img src="http://note.youdao.com/yws/res/1704/6EF4A6F08199452FADA904A58A49AA82" alt="image"></p><p><img src="http://note.youdao.com/yws/res/1707/61F8AAC21B744B378A32C216B2451EC1" alt="image"></p><p><img src="http://note.youdao.com/yws/res/1709/AA3E453BE9844CD08FC75C9068A5926A" alt="image"></p><p><img src="http://note.youdao.com/yws/res/1711/8AF73D8AD5054296A8D9BF8302169CB2" alt="image"></p><p><img src="http://note.youdao.com/yws/res/1713/D7C08C97D0C1440EBE78EE88422D1631" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/3364/66114E8FDCDB479FB0DE7AC6825712C2&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
      <category term="react" scheme="https://matisha001.github.io/tags/react/"/>
    
      <category term="frame" scheme="https://matisha001.github.io/tags/frame/"/>
    
  </entry>
  
  <entry>
    <title>vue2.0生命周期</title>
    <link href="https://matisha001.github.io/2016/09/25/vue2.x%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://matisha001.github.io/2016/09/25/vue2.x生命周期/</id>
    <published>2016-09-24T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.638Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="https://note.youdao.com/yws/res/7869/C6254C9D40F742CB96B3032A69FC6AFD" alt="image"></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期&quot; class=&quot;headerlink&quot; title=&quot;生命周期&quot;&gt;&lt;/a&gt;生命周期&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/res/7869/C6254C9D40F742C
      
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
      <category term="frame" scheme="https://matisha001.github.io/tags/frame/"/>
    
      <category term="vue" scheme="https://matisha001.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue2过渡效果总结</title>
    <link href="https://matisha001.github.io/2016/09/25/vue2.x%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C%E6%80%BB%E7%BB%93/"/>
    <id>https://matisha001.github.io/2016/09/25/vue2.x过渡效果总结/</id>
    <published>2016-09-24T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单元素过渡"><a href="#单元素过渡" class="headerlink" title="单元素过渡"></a>单元素过渡</h2><p>Vue 提供了 transition 的封装组件</p><ul><li>条件渲染 （使用 v-if）</li><li>条件展示 （使用 v-show）</li><li>动态组件</li><li>组件根节点</li></ul><p>当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理：</p><ol><li>自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。</li><li>如果过渡组件设置了过渡的 JavaScript 钩子函数，会在相应的阶段调用钩子函数。</li><li>如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。</li></ol><hr><a id="more"></a><h3 id="过渡的-CSS-类名"><a href="#过渡的-CSS-类名" class="headerlink" title="过渡的-CSS-类名"></a>过渡的-CSS-类名</h3><p>会有 6 个(CSS)类名在 enter/leave 的过渡中切换</p><ul><li>v-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。</li><li>v-enter-active: 定义过渡的状态。在元素整个过渡过程中作用，在元素被插入时生效，在 transition/animation 完成之后移除。 </li><li>v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入一帧后生效（于此同时 v-enter 被删除），在 transition/animation 完成之后移除。</li><li>v-leave: 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。</li><li>v-leave-active: 定义过渡的状态。在元素整个过渡过程中作用，在离开过渡被触发后立即生效，在 transition/animation 完成之后移除。 </li><li>v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发一帧后生效（于此同时 v-leave 被删除），在 transition/animation 完成之后移除。</li></ul><p><img src="https://note.youdao.com/yws/res/16273/8F678DDC6FC049D590690F68619B8860" alt="image"> </p><p>这些在 enter/leave 过渡中切换的类名，v- 是这些类名的前缀。使用 <transition name="my-transition"> 可以重置前缀，比如 v-enter 替换为 my-transition-enter。</transition></p><p><img src="https://note.youdao.com/yws/res/5421/AA5F28067D684BBB98FE7A211AF86278" alt="image"></p><hr><h3 id="CSS-过渡与动画"><a href="#CSS-过渡与动画" class="headerlink" title="CSS 过渡与动画"></a>CSS 过渡与动画</h3><ul><li>主要是在css中使用transition,transform,animation,keyframes等css3属性。</li><li>CSS 动画用法同 CSS 过渡，区别是在动画中 v-enter 类名在节点插入 DOM 后不会立即删除，而是在 animationend事件触发时删除。</li></ul><p><img src="http://note.youdao.com/yws/res/5424/E0E04D2B1B444BBC9A9DDAD632A44F76" alt="image"></p><hr><h3 id="自定义过渡类名"><a href="#自定义过渡类名" class="headerlink" title="自定义过渡类名"></a>自定义过渡类名</h3><ul><li>使用自定义过渡类名的特点就是优先级高于普通的类名,可以与第三方css动画库一起使用。</li></ul><p><img src="http://note.youdao.com/yws/res/5427/ACF0A3EA7BE74C1B974DBDF0857D2DDF" alt="image"></p><hr><h3 id="同时使用-Transitions-和-Animations"><a href="#同时使用-Transitions-和-Animations" class="headerlink" title="同时使用 Transitions 和 Animations"></a>同时使用 Transitions 和 Animations</h3><p>Vue 为了知道过渡的完成，必须设置相应的事件监听器。可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。使用其中任何一种，Vue 能自动识别类型并设置监听。</p><p>同一个元素同时设置两种过渡动效，比如 animation很快的被触发并完成了，而transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。</p><hr><h3 id="过渡效果持续时间-（2-2-0版本-）"><a href="#过渡效果持续时间-（2-2-0版本-）" class="headerlink" title="过渡效果持续时间 （2.2.0版本 ）"></a>过渡效果持续时间 （2.2.0版本 ）</h3><ul><li>一些嵌套的内部元素相比于过渡效果的根元素有延迟的或更长的过渡效果。在这种情况下你可以用 <transition> 组件上的 duration 属性定制一个显性的过渡效果持续时间 (以毫秒计)。</transition></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;transition :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt;...&lt;/transition&gt;</div></pre></td></tr></table></figure><hr><h3 id="javascript实现过渡效果"><a href="#javascript实现过渡效果" class="headerlink" title="javascript实现过渡效果"></a>javascript实现过渡效果</h3><ul><li><p>当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。 否则，它们会被同步调用，过渡会立即完成。</p></li><li><p>使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。</p></li></ul><p><img src="http://note.youdao.com/yws/res/16375/WEBRESOURCE4a67d5cf26e2088e1358583f853f4f2c" alt="image"></p><hr><h3 id="初始渲染过渡"><a href="#初始渲染过渡" class="headerlink" title="初始渲染过渡"></a>初始渲染过渡</h3><blockquote><p>可以通过 appear特性设置节点的在初始渲染的过渡。默认和进入和离开过渡一样，可以自定义 CSS 类名，也可以使用js钩子。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;transition</div><div class="line">  appear</div><div class="line">  appear-class=&quot;custom-appear-class&quot;</div><div class="line">  appear-to-class=&quot;custom-appear-to-class&quot; (2.1.8+)</div><div class="line">  appear-active-class=&quot;custom-appear-active-class&quot;</div><div class="line">  v-on:appear=&quot;customAppearHook&quot;</div><div class="line">  v-on:appear-cancelled=&quot;customAppearCancelledHook&quot;</div><div class="line">&gt;</div><div class="line">  &lt;!-- ... --&gt;</div><div class="line">&lt;/transition&gt;</div></pre></td></tr></table></figure><hr><h2 id="多元素过渡"><a href="#多元素过渡" class="headerlink" title="多元素过渡"></a>多元素过渡</h2><p>多个组件的过渡, 对于原生标签可以使用 v-if/v-else 。<br>当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。</p><p><img src="http://note.youdao.com/yws/res/1255/EE6D30032C714B20A86B2F5E56551129" alt="image"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:key</span>=<span class="string">"docState"</span>&gt;</span></div><div class="line">    &#123;&#123; buttonMessage &#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure><hr><h3 id="过渡模式"><a href="#过渡模式" class="headerlink" title="过渡模式"></a>过渡模式</h3><ul><li>一个离开过渡的时候另一个开始进入过渡。这是 <transition> 的默认行为 - 进入和离开同时发生。</transition></li></ul><blockquote><p>同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了 过渡模式</p><ul><li>in-out: 新元素先进行过渡，完成之后当前元素过渡离开。</li><li>out-in: 当前元素先进行过渡，完成之后新元素过渡进入。</li></ul></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span> <span class="attr">mode</span>=<span class="string">"out-in"</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- ... the buttons ... --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure><hr><h2 id="多组件过渡"><a href="#多组件过渡" class="headerlink" title="多组件过渡"></a>多组件过渡</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;test&quot;&gt;</div><div class="line">    &lt;transition name=&quot;component-fade&quot; mode=&quot;out-in&quot;&gt;</div><div class="line">      &lt;component v-bind:is=&quot;view&quot;&gt;&lt;/component&gt;</div><div class="line">    &lt;/transition&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">new Vue(&#123;</div><div class="line">  el: &apos;#test&apos;,</div><div class="line">  data: &#123;</div><div class="line">    view: &apos;v-a&apos;</div><div class="line">  &#125;,</div><div class="line">  components: &#123;</div><div class="line">    &apos;v-a&apos;: &#123;</div><div class="line">      template: &apos;&lt;div&gt;Component A&lt;/div&gt;&apos;</div><div class="line">    &#125;,</div><div class="line">    &apos;v-b&apos;: &#123;</div><div class="line">      template: &apos;&lt;div&gt;Component B&lt;/div&gt;&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><h3 id="列表过渡"><a href="#列表过渡" class="headerlink" title="列表过渡"></a>列表过渡</h3><p>使用 <transition-group> 组件,同时渲染整个列表</transition-group></p><ul><li>不同于 <transition>,它会以一个真实元素呈现：默认为一个 <span>。也可以通过 tag 特性更换为其他元素。</span></transition></li><li>内部元素 总是需要 提供唯一的 key 属性值</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"list-demo"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"add"</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"remove"</span>&gt;</span>Remove<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">name</span>=<span class="string">"list"</span> <span class="attr">tag</span>=<span class="string">"p"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item"</span> <span class="attr">class</span>=<span class="string">"list-item"</span>&gt;</span></div><div class="line">      &#123;&#123; item &#125;&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="列表位移过渡"><a href="#列表位移过渡" class="headerlink" title="列表位移过渡"></a>列表位移过渡</h4><p><transition-group>组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置。</transition-group></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单元素过渡&quot;&gt;&lt;a href=&quot;#单元素过渡&quot; class=&quot;headerlink&quot; title=&quot;单元素过渡&quot;&gt;&lt;/a&gt;单元素过渡&lt;/h2&gt;&lt;p&gt;Vue 提供了 transition 的封装组件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;条件渲染 （使用 v-if）&lt;/li&gt;
&lt;li&gt;条件展示 （使用 v-show）&lt;/li&gt;
&lt;li&gt;动态组件&lt;/li&gt;
&lt;li&gt;组件根节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自动嗅探目标元素是否有 CSS 过渡或动画，并在合适时添加/删除 CSS 类名。&lt;/li&gt;
&lt;li&gt;如果过渡组件设置了过渡的 JavaScript 钩子函数，会在相应的阶段调用钩子函数。&lt;/li&gt;
&lt;li&gt;如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作（插入/删除）在下一帧中立即执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
      <category term="frame" scheme="https://matisha001.github.io/tags/frame/"/>
    
      <category term="vue" scheme="https://matisha001.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue1.x 与vue 2.x的区别</title>
    <link href="https://matisha001.github.io/2016/09/19/vue1.x%20%E4%B8%8Evue%202.x%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://matisha001.github.io/2016/09/19/vue1.x 与vue 2.x的区别/</id>
    <published>2016-09-18T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue1-x-与vue-2-x的生命周期区别"><a href="#vue1-x-与vue-2-x的生命周期区别" class="headerlink" title="vue1.x 与vue 2.x的生命周期区别"></a>vue1.x 与vue 2.x的生命周期区别</h3><p><img src="http://note.youdao.com/yws/res/4079/9BA996B72E374A578B5F89B7A5C56049" alt="image"></p><h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><blockquote><p>在版本vue1.x中,prop默认是单向绑定：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。可以使用.sync 或 .once 绑定修饰符显式地强制双向或单次绑定。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 默认为单向绑定 --&gt;</div><div class="line">&lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;</div><div class="line">&lt;!-- 双向绑定 --&gt;</div><div class="line">&lt;child v-bind:my-message.sync=&quot;parentMsg&quot;&gt;&lt;/child&gt;</div><div class="line">&lt;!-- 单次绑定 --&gt;</div><div class="line">&lt;child v-bind:my-message.once=&quot;parentMsg&quot;&gt;&lt;/child&gt;</div></pre></td></tr></table></figure><p>详细见<a href="http://github.matisha.pw" target="_blank" rel="external">vue2.x事件与数据绑定</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;vue1-x-与vue-2-x的生命周期区别&quot;&gt;&lt;a href=&quot;#vue1-x-与vue-2-x的生命周期区别&quot; class=&quot;headerlink&quot; title=&quot;vue1.x 与vue 2.x的生命周期区别&quot;&gt;&lt;/a&gt;vue1.x 与vue 2.x的生命周期区别&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://note.youdao.com/yws/res/4079/9BA996B72E374A578B5F89B7A5C56049&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
      <category term="frame" scheme="https://matisha001.github.io/tags/frame/"/>
    
      <category term="vue" scheme="https://matisha001.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>js-事件冒泡机制</title>
    <link href="https://matisha001.github.io/2016/03/19/js-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E6%9C%BA%E5%88%B6/"/>
    <id>https://matisha001.github.io/2016/03/19/js-事件冒泡机制/</id>
    <published>2016-03-18T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><blockquote><p>点击li弹出对应的innerHTML。</p></blockquote><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>item5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure><p>当需要对很多元素添加事件的时，可以通过将事件添加到它们的父节点通过委托来触发处理函数。其中利用到了浏览器的事件冒泡机制。</p><p>jquery方案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"ul"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;   </div><div class="line">    <span class="built_in">console</span>.log(e.target.innerHTML)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><p>javascript封装（参考）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">el, ev, sel, fn</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(fn == <span class="literal">null</span>) &#123;</div><div class="line">        fn = sel;</div><div class="line">        sel = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    el.addEventListener(ev,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> target;</div><div class="line">        e.preventDefault();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(sel)&#123;</div><div class="line">            target = e.target;</div><div class="line">            <span class="keyword">if</span>(target.matches(sel))&#123;</div><div class="line">                fn.call(target, e)</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            fn(e);</div><div class="line">        &#125;</div><div class="line">    &#125;) </div><div class="line">&#125;</div><div class="line"></div><div class="line">bindEvent(<span class="string">'ul'</span>,<span class="string">'click'</span>,<span class="string">'li'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.innerHTML);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>DOM2.0模型将事件处理流程分为三个阶段：事件捕获阶段、事件目标阶段、事件起泡阶段</p><p><strong>事件捕获</strong>：当某个元素触发某个事件（如onclick），顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。在这个过程中，事件相应的监听函数是不会被触发的。</p><p><strong>事件目标</strong>：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。</p><p><strong>事件起泡</strong>：从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。如果想阻止事件起泡，可以使用e.stopPropagation()（Firefox）或者e.cancelBubble=true（IE）来组织事件的冒泡传播。</p><p><a href="http://www.jianshu.com/p/8e505fe77762" target="_blank" rel="external">2017前端面试题之Js篇（1）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;点击li弹出对应的innerHTML。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ES6新增特性</title>
    <link href="https://matisha001.github.io/2016/02/19/es6/"/>
    <id>https://matisha001.github.io/2016/02/19/es6/</id>
    <published>2016-02-18T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="let和const命令"><a href="#let和const命令" class="headerlink" title="let和const命令"></a>let和const命令</h2><blockquote><p>不存在变量提升<br>不可重复声明<br>只在声明所在的块级作用域内有效<br>对于const来说只声明不赋值会报错</p></blockquote><a id="more"></a><h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></div></pre></td></tr></table></figure><p>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></div></pre></td></tr></table></figure></p><p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line"><span class="keyword">let</span> i = <span class="string">'abc'</span>;</div><div class="line"><span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// abc</span></div><div class="line"><span class="comment">// abc</span></div><div class="line"><span class="comment">// abc</span></div></pre></td></tr></table></figure></p><p>不存在变量提升，let所声明的变量一定要在声明后使用，否则报错。var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。</p><h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</div><div class="line">a <span class="comment">// 1</span></div><div class="line"></div><div class="line">a = <span class="number">2</span>;</div><div class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></div></pre></td></tr></table></figure></p><p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo;</div><div class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></div></pre></td></tr></table></figure></p><hr><h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><blockquote><p>变量的声明和赋值是一体的，使用let或者const不可以重复定义</p></blockquote><p>es6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值。本质是模式匹配。</p><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><p>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p><p>数组模式和赋值模式统一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [a,[b,c],d]=[<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="number">4</span>];</div></pre></td></tr></table></figure><p>如果等号两边形式不一样，很可能获得undefined或者直接报错。</p><p>解构的默认值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] =[];</div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//控制台打印出true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [a,b=<span class="string">"Feng"</span>]=[<span class="string">'hello'</span>]</div><div class="line"><span class="built_in">console</span>.log(a+b); <span class="comment">//控制台显示“helloFeng”</span></div></pre></td></tr></table></figure><p>需要注意的是undefined和null的区别<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [a,b=<span class="string">"Feng"</span>]=[<span class="string">'hello'</span>,<span class="literal">undefined</span>];</div><div class="line"><span class="built_in">console</span>.log(a+b); <span class="comment">//控制台显示“helloFeng”</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [a,b=<span class="string">"Feng"</span>]=[<span class="string">'hello'</span>,<span class="literal">null</span>];</div><div class="line"><span class="built_in">console</span>.log(a+b); <span class="comment">//控制台显示“hellonull”</span></div></pre></td></tr></table></figure></p><p>undefined相当于什么都没有，b是默认值。null相当于有值，但值为null。所以b并没有取默认值，而是解构成了null。</p><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><blockquote><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p></blockquote><p>如果在解构之前就定义了变量，这时候你再解构会出现问题。加圆括号解决：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> foo;</div><div class="line">(&#123;foo&#125; =&#123;<span class="attr">foo</span>:<span class="string">'Feng'</span>&#125;);</div><div class="line"><span class="built_in">console</span>.log(foo); <span class="comment">//控制台输出Feng</span></div></pre></td></tr></table></figure></p><hr><h2 id="扩展运算符和rest运算符"><a href="#扩展运算符和rest运算符" class="headerlink" title="扩展运算符和rest运算符"></a>扩展运算符和rest运算符</h2><h3 id="对象扩展运算符（…）"><a href="#对象扩展运算符（…）" class="headerlink" title="对象扩展运算符（…）"></a>对象扩展运算符（…）</h3><p>当编写一个方法时，我们允许它传入的参数是不确定的。这时候可以使用对象扩展运算符来作参数，看一个简单的列子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...arg</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(arg[<span class="number">0</span>]);</div><div class="line">    <span class="built_in">console</span>.log(arg[<span class="number">1</span>]);</div><div class="line">    <span class="built_in">console</span>.log(arg[<span class="number">2</span>]);</div><div class="line">    <span class="built_in">console</span>.log(arg[<span class="number">3</span>]);</div><div class="line"> </div><div class="line">&#125;</div><div class="line">foo(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//1,2,3，undefined</span></div></pre></td></tr></table></figure></p><p>这样，可以传入多个值，并且就算方法中引用多了也不会报错。</p><p>扩展运算符的用处：</p><blockquote><p>我们先用一个例子说明，我们声明两个数组arr1和arr2，然后我们把arr1赋值给arr2，然后我们改变arr2的值，你会发现arr1的值也改变了，因为我们这是对内存堆栈的引用，而不是真正的赋值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr1=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</div><div class="line"><span class="keyword">let</span> arr2=arr1;</div><div class="line"><span class="built_in">console</span>.log(arr2);<span class="comment">//["a", "b", "c"]</span></div><div class="line">arr2.push(<span class="string">'D'</span>);</div><div class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">//["a", "b", "c", "D"]</span></div></pre></td></tr></table></figure></p></blockquote><p>显然这不是我们想要的，可以利用扩展运算符解决：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr1=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</div><div class="line"><span class="comment">//let arr2=arr1;</span></div><div class="line"><span class="keyword">let</span> arr2=[...arr1];</div><div class="line"><span class="built_in">console</span>.log(arr2);<span class="comment">//["a", "b", "c"]</span></div><div class="line">arr2.push(<span class="string">'D'</span>);</div><div class="line"><span class="built_in">console</span>.log(arr2);<span class="comment">//["a", "b", "c", "D"]</span></div><div class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">//["a", "b", "c"]</span></div></pre></td></tr></table></figure></p><h3 id="rest运算符"><a href="#rest运算符" class="headerlink" title="rest运算符"></a>rest运算符</h3><p>如果你已经很好的掌握了对象扩展运算符，那么理解rest运算符并不困难，它们有很多相似之处，甚至很多时候你不用特意去区分。它也用…（三个点）来表示，我们先来看一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">first,...arg</span>)</span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> arg)&#123;</div><div class="line">        <span class="built_in">console</span>.log(val);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">foo(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</div></pre></td></tr></table></figure></p><hr><h2 id="字符串模版"><a href="#字符串模版" class="headerlink" title="字符串模版"></a>字符串模版</h2><p>ES6对字符串新增的操作，最重要的就是字符串模版，字符串模版的出现让我们再也不用拼接变量了，而且支持在模板里有简单计算操作。</p><h3 id="字符串模版-1"><a href="#字符串模版-1" class="headerlink" title="字符串模版"></a>字符串模版</h3><p>支持html标签:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> hello=<span class="string">'hello'</span>;</div><div class="line"><span class="keyword">let</span> hw = <span class="string">`<span class="subst">$&#123;hello&#125;</span>&lt;b&gt;world!&lt;/b&gt;&lt;br/&gt;字符串模版。`</span>;</div><div class="line"><span class="built_in">document</span>.write(hw);</div></pre></td></tr></table></figure><p>对运算的支持：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a=<span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> b=<span class="number">2</span>;</div><div class="line"><span class="keyword">let</span> result=<span class="string">`<span class="subst">$&#123;a+b&#125;</span>`</span>;</div><div class="line"><span class="built_in">document</span>.write(result);</div></pre></td></tr></table></figure><h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><blockquote><p>ES6还增加了字符串的查找功能，而且支持中文!</p></blockquote><p>查找是否存在:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> hello=<span class="string">'你好'</span>;</div><div class="line"><span class="keyword">let</span> hw = <span class="string">'。。。你好！world！'</span>;</div><div class="line"><span class="built_in">console</span>.log(hw.indexOf(hello));<span class="comment">//3 ES5</span></div><div class="line"><span class="built_in">console</span>.log(hw.includes(hello));<span class="comment">//true ES6</span></div></pre></td></tr></table></figure></p><p>判断开头是否存在：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(hw.startsWith(hello));</div></pre></td></tr></table></figure></p><p>判断结尾是否存在：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(hw.endsWith(hello));</div></pre></td></tr></table></figure></p><h3 id="复制字符串"><a href="#复制字符串" class="headerlink" title="复制字符串"></a>复制字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'ha |'</span>.repeat(<span class="number">3</span>));<span class="comment">//ha |ha |ha |</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;let和const命令&quot;&gt;&lt;a href=&quot;#let和const命令&quot; class=&quot;headerlink&quot; title=&quot;let和const命令&quot;&gt;&lt;/a&gt;let和const命令&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;不存在变量提升&lt;br&gt;不可重复声明&lt;br&gt;只在声明所在的块级作用域内有效&lt;br&gt;对于const来说只声明不赋值会报错&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
      <category term="es6" scheme="https://matisha001.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>Javascript经典算法</title>
    <link href="https://matisha001.github.io/2015/09/19/javascript%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"/>
    <id>https://matisha001.github.io/2015/09/19/javascript经典算法/</id>
    <published>2015-09-18T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.619Z</updated>
    
    <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;arr.length<span class="number">-1</span>; i++)&#123;</div><div class="line">    <span class="keyword">for</span>(j=i+<span class="number">1</span>; j&lt;arr.length; j++)&#123;</div><div class="line">      <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</div><div class="line">        <span class="keyword">var</span> temp = arr[i];</div><div class="line">        arr[i] = arr[j];</div><div class="line">        arr[j] = temp;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><blockquote><p>利用Object中key的唯一性，用key来进行筛选。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> obj = &#123;&#125;</div><div class="line">  <span class="keyword">var</span> result = []</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123;</div><div class="line">    <span class="keyword">if</span>(!obj[arr[i]])&#123;</div><div class="line">      obj[arr[i]] = <span class="literal">true</span>;</div><div class="line">      result.push(arr[i]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="comment">//ES6中Set实现：</span></div><div class="line"><span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]);</div></pre></td></tr></table></figure><h3 id="数组中最大差值"><a href="#数组中最大差值" class="headerlink" title="数组中最大差值"></a>数组中最大差值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxProfit</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> min = arr[<span class="number">0</span>],</div><div class="line">      max = arr[<span class="number">0</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">    <span class="keyword">if</span>(arr[i] &lt; min) min = arr[i];</div><div class="line">    <span class="keyword">if</span>(arr[i] &gt; max) max = arr[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> max - min;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="统计字符串中次数最多字母"><a href="#统计字符串中次数最多字母" class="headerlink" title="统计字符串中次数最多字母"></a>统计字符串中次数最多字母</h3><blockquote><p>利用Object中key的唯一性，用key来进行筛选并计数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMaxDuplicateChar</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span>(str.length == <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> str;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> charObj = &#123;&#125;;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span>(!charObj[str.charAt(i)]) &#123;</div><div class="line">      charObj[str.charAt(i)] = <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      charObj[str.charAt(i)] += <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">var</span> maxChar = <span class="string">''</span>,</div><div class="line">      maxValue = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> charObj) &#123;</div><div class="line">    <span class="keyword">if</span>(charObj[k] &gt;= maxValue) &#123;</div><div class="line">      maxChar = k;</div><div class="line">      maxValue = charObj[k];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> maxChar + <span class="string">'：'</span> + maxValue;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="翻转字符串"><a href="#翻转字符串" class="headerlink" title="翻转字符串"></a>翻转字符串</h3><blockquote><p>反向遍历字符串</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> tmp = <span class="string">''</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=str.length<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</div><div class="line">    tmp += str[i];</div><div class="line">  <span class="keyword">return</span> tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>转化成array操作</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> arr = str.split(<span class="string">""</span>);</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span>,j = arr.length<span class="number">-1</span>;</div><div class="line">  <span class="keyword">while</span>(i&lt;j)&#123;</div><div class="line">    tmp = arr[i];</div><div class="line">    arr[i] = arr[j];</div><div class="line">    arr[j] = tmp;</div><div class="line">    i++;</div><div class="line">    j--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> arr.join(<span class="string">""</span>);</div><div class="line">----------------------</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseString</span>(<span class="params">str</span>) </span>&#123;</div><div class="line"> str = str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</div><div class="line"> <span class="keyword">return</span> str;</div><div class="line">&#125;</div><div class="line">reverseString(<span class="string">"hello"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="生成指定长度随机字符串"><a href="#生成指定长度随机字符串" class="headerlink" title="生成指定长度随机字符串"></a>生成指定长度随机字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomString</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> str = <span class="string">'abcdefghijklmnopqrstuvwxyz0123456789'</span>;</div><div class="line">  <span class="keyword">var</span> tmp = <span class="string">''</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</div><div class="line">    tmp += str.charAt(<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random()*str.length));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="生成菲波那切数列（强制）"><a href="#生成菲波那切数列（强制）" class="headerlink" title="生成菲波那切数列（强制）"></a>生成菲波那切数列（强制）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getfib</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">if</span>(n &gt; <span class="number">1</span>) <span class="keyword">return</span> getfib(n<span class="number">-1</span>) + getfib(n<span class="number">-2</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibo</span>(<span class="params">len</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> fibo = [];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">      fibo.push(getfib(i));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fibo;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">     </div><div class="line">     <span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>)&#123;</div><div class="line">         <span class="keyword">return</span> arr;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">//定义一个左数组，定义一个右数组</span></div><div class="line">     <span class="keyword">let</span> leftArr = [];</div><div class="line">     <span class="keyword">let</span> rightArr = [];</div><div class="line">    <span class="comment">//选定一个参照值</span></div><div class="line">    <span class="keyword">let</span> tag = arr[<span class="number">0</span>];</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * 使用如下方式判断，会把重复元素去掉，就实现了快排的同时去重</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(arr[i] &lt; tag)&#123; <span class="comment">//将比tag小的元素放在左数组中</span></div><div class="line">            leftArr.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(arr[i] &gt; tag)&#123; <span class="comment">//将比tag大的元素放在右数组中</span></div><div class="line">            rightArr.push(arr[i]);</div><div class="line">        &#125;</div><div class="line">   &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//使用如下方式就是使用快排进行排序，不去重</span></div><div class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(arr[i] &lt; tag)&#123; <span class="comment">//将比tag小的元素放在左数组中</span></div><div class="line">            leftArr.push(arr[i]);</div><div class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//将比tag大的元素放在右数组中</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//递归调用</span></div><div class="line">    <span class="keyword">return</span> [].concat(quickSort(leftArr),[tag],quickSort(rightArr));</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bubbleSort&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arr&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;arr.length&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;; i++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(j=i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j&amp;lt;arr.length; j++)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(arr[i] &amp;gt; arr[j])&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; temp = arr[i];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        arr[i] = arr[j];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        arr[j] = temp;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arr;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>CSS总结</title>
    <link href="https://matisha001.github.io/2015/01/19/CSS%E6%80%BB%E7%BB%93/"/>
    <id>https://matisha001.github.io/2015/01/19/CSS总结/</id>
    <published>2015-01-18T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.611Z</updated>
    
    <content type="html"><![CDATA[<h3 id="当margin的值为百分比形式时-为什么浏览器会根据父容器宽度得出计算值？"><a href="#当margin的值为百分比形式时-为什么浏览器会根据父容器宽度得出计算值？" class="headerlink" title="当margin的值为百分比形式时,为什么浏览器会根据父容器宽度得出计算值？"></a>当margin的值为百分比形式时,为什么浏览器会根据父容器宽度得出计算值？</h3><p>一个符合W3C标准的浏览器会根据父容器的宽度进行计算，但是这个仅限于书写模式为横向的时候。因为在横向排版时，宽度”有迹可循”，可以把浏览器宽度作为参考，但是高度是不固定的，所以margin百分比值在计算时会参考父容器的宽度。当书写模式改为纵向，其计算参考便会变为父容器的高度了。</p><blockquote><p>demo<br><a href="http://dongtianee.sinaapp.com/demo6.html" target="_blank" rel="external">http://dongtianee.sinaapp.com/demo6.html</a></p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*修改书写模式*/</span></div><div class="line"><span class="selector-class">.demo</span>&#123;</div><div class="line"><span class="attribute">-webkit-writing-mode</span>: vertical-rl; <span class="comment">/* for webkit */</span></div><div class="line">　　 <span class="attribute">writing-mode</span>: tb-rl; <span class="comment">/* for ie */</span>       </div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>结论：一个符合W3C标准的浏览器,当margin的值为百分比形式时,会根据书写的模式来判断根据高度还是宽度来计算 </p></blockquote><h3 id="margin：auto为什么只能实现水平居中，不能垂直居中？"><a href="#margin：auto为什么只能实现水平居中，不能垂直居中？" class="headerlink" title="margin：auto为什么只能实现水平居中，不能垂直居中？"></a>margin：auto为什么只能实现水平居中，不能垂直居中？</h3><p>网页排版时，常规流的块级元素水平方向总是铺满浏览器窗口,垂直方向各块级元素按照先后顺序从上往下排列,当页面内容过多时网页会出现纵向滚动条，因此原理上纵向是可以无限扩展的,计算时找不到一个固定的参考值,所以纵向的auto无法生效。</p><p>margin:auto会受书写模式的影响。当书写模式为纵向时，margin：auto垂直方向是可以居中的。其实受到书写模式影响的属性除了这些外，还有margin折叠、padding百分比值的计算等。</p><h3 id="清除浮动有N种方式，他们间有什么共同点吗？"><a href="#清除浮动有N种方式，他们间有什么共同点吗？" class="headerlink" title="清除浮动有N种方式，他们间有什么共同点吗？"></a>清除浮动有N种方式，他们间有什么共同点吗？</h3><p>所谓清除浮动，一般是为了解决子元素浮动导致父容器高度坍塌。<br><img src="https://note.youdao.com/yws/res/16190/WEBRESOURCE2f6b5ed67cbaf70627c7593ef3f3e48c" alt="image"></p><h3 id="一个position-fixed的元素相对于一个容器定位而非浏览器视口吗？"><a href="#一个position-fixed的元素相对于一个容器定位而非浏览器视口吗？" class="headerlink" title="一个position:fixed的元素相对于一个容器定位而非浏览器视口吗？"></a>一个position:fixed的元素相对于一个容器定位而非浏览器视口吗？</h3><p>CSS实现了一个position:fixed的元素相对于一个容器定位</p><p>当一个元素应用了CSS3的transform属性后，它的后代元素的fixed都将失效。</p><h3 id="怪异盒模型box-sizing？弹性盒模型-盒布局"><a href="#怪异盒模型box-sizing？弹性盒模型-盒布局" class="headerlink" title="怪异盒模型box-sizing？弹性盒模型|盒布局?"></a>怪异盒模型box-sizing？弹性盒模型|盒布局?</h3><p> 在标准模式下的盒模型：盒子总宽度/高度=width/height+padding+border+margin<br>在怪异模式下的盒模型下，盒子的总宽度和高度是包含内边距padding和边框border宽度在内的，盒子总宽度/高度=width/height + margin = 内容区宽度/高度 + padding + border + margin;<br>box-sizing有两个值一个是content-box，另一个是border-box。<br>当设置为box-sizing:content-box时，将采用标准模式解析计算；<br>当设置为box-sizing:border-box时，将采用怪异模式解析计算。</p><h3 id="a点击出现框，解决方法"><a href="#a点击出现框，解决方法" class="headerlink" title="a点击出现框，解决方法:"></a>a点击出现框，解决方法:</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span>,<span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,<span class="selector-tag">a</span><span class="selector-pseudo">:active</span>,<span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>,<span class="selector-tag">a</span><span class="selector-pseudo">:link</span>,<span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>&#123; </div><div class="line">    <span class="attribute">-webkit-tap-highlight-color</span>:<span class="built_in">rgba</span>(0,0,0,0);</div><div class="line">    <span class="attribute">-webkit-tap-highlight-color</span>: transparent;</div><div class="line">    <span class="attribute">outline</span>:none;<span class="attribute">background</span>: none;</div><div class="line">    <span class="attribute">text-decoration</span>: none;<span class="attribute">border</span>:none;</div><div class="line">    <span class="attribute">-webkit-appearance</span>: none; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="图片和文字在同一行显示"><a href="#图片和文字在同一行显示" class="headerlink" title="图片和文字在同一行显示?"></a>图片和文字在同一行显示?</h3><p>1、在css中给div添加上“vertical-align:middle”属性。<br>2、分别把图片和文字放入不同的div中，然后用“margin”属性进行定位，就可以使他们显示在同一行。<br>3、把图片设置为背景图片。</p><h3 id="CSS实现面板的隐藏和显示的三种方式"><a href="#CSS实现面板的隐藏和显示的三种方式" class="headerlink" title="CSS实现面板的隐藏和显示的三种方式"></a>CSS实现面板的隐藏和显示的三种方式</h3><p>第一种利用了label和checkbox，使控制方和被控制方不需要有特定的HTML结构关系，但是需要额外的HTML标签来支持。第二种方式利用了hover和子元素选择器，第三种方式利用了focus和兄弟元素选择器，后两种都受限于特定的HTML结构。三种方法都只使用CSS实现了面板的隐藏显示。</p><blockquote><p>demo  <a href="http://dongtianee.sinaapp.com/demo8.html" target="_blank" rel="external">http://dongtianee.sinaapp.com/demo8.html</a></p></blockquote><h3 id="CSS图标"><a href="#CSS图标" class="headerlink" title="CSS图标"></a>CSS图标</h3><blockquote><p>demo <a href="http://www.uiplayground.in/css3-icons/" target="_blank" rel="external">http://www.uiplayground.in/css3-icons/</a></p></blockquote><h3 id="针对IE6，7的hack"><a href="#针对IE6，7的hack" class="headerlink" title="针对IE6，7的hack"></a>针对IE6，7的hack</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="comment">&lt;!--[if lt IE 7 ]&gt;&lt;html class="ie6"&gt;&lt;![endif]--&gt;</span></div><div class="line"><span class="comment">&lt;!--[if IE 7 ]&gt;&lt;html class="ie7"&gt;&lt;![endif]--&gt;</span></div><div class="line"><span class="comment">&lt;!--[if IE 8 ]&gt;&lt;html class="ie8"&gt;&lt;![endif]--&gt;</span></div><div class="line"><span class="comment">&lt;!--[if IE 9 ]&gt;&lt;html class="ie9"&gt;&lt;![endif]--&gt;</span></div><div class="line"><span class="comment">&lt;!--[if (gt IE 9)|!(IE)]&gt;&lt;!--&gt;</span><span class="tag">&lt;<span class="name">html</span> <span class="attr">class</span>=<span class="string">"w3c"</span>&gt;</span><span class="comment">&lt;!--&lt;![endif]--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.ie7</span> <span class="selector-id">#hd_usernav</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.ie8</span> <span class="selector-id">#hd_usernav</span><span class="selector-pseudo">:before</span> &#123;</div><div class="line"><span class="attribute">display</span>: none</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.ie6</span> <span class="selector-class">.skin_no</span> <span class="selector-id">#hd_nav</span> <span class="selector-tag">li</span>, <span class="selector-class">.ie7</span> <span class="selector-class">.skin_no</span> <span class="selector-id">#hd_nav</span> <span class="selector-tag">li</span>, <span class="selector-class">.ie8</span> <span class="selector-class">.skin_no</span> <span class="selector-id">#hd_nav</span> <span class="selector-tag">li</span> &#123;</div><div class="line"><span class="attribute">border-right-color</span>: <span class="number">#c5c5c5</span></div><div class="line">&#125;</div><div class="line"><span class="selector-class">.ie6</span> <span class="selector-class">.skin_no</span> <span class="selector-id">#hd_nav</span> <span class="selector-tag">a</span>, <span class="selector-class">.ie7</span> <span class="selector-class">.skin_no</span> <span class="selector-id">#hd_nav</span> <span class="selector-tag">a</span>, <span class="selector-class">.ie8</span> <span class="selector-class">.skin_no</span> <span class="selector-id">#hd_nav</span> <span class="selector-tag">a</span> &#123;</div><div class="line"><span class="attribute">color</span>: <span class="number">#c5c5c5</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="行内级元素可以设置宽高吗？"><a href="#行内级元素可以设置宽高吗？" class="headerlink" title="行内级元素可以设置宽高吗？"></a>行内级元素可以设置宽高吗？</h3><p>有一些特殊的行内元素，比如img，input，select等等，是可以被设置宽高的。一个内容不受CSS视觉格式化模型控制，CSS渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，被称之为置换元素。比如img是一个置换元素，当不对它设置宽高时，它会按照本身的宽高进行显示。</p><h3 id="CSS规则根据优先级生效，低优先级的规则会被浏览器忽略还是覆盖？"><a href="#CSS规则根据优先级生效，低优先级的规则会被浏览器忽略还是覆盖？" class="headerlink" title="CSS规则根据优先级生效，低优先级的规则会被浏览器忽略还是覆盖？"></a>CSS规则根据优先级生效，低优先级的规则会被浏览器忽略还是覆盖？</h3><p>多个优先级的样式都会被渲染，只不过高优先级会覆盖住低优先级，元素呈现为高优先级的样式。<br>浏览器只会为生效的CSS规则中的图片资源发出http请求。</p><p>在现代浏览器中，一个页面从请求到呈现，大致需要经过解析-构建DOM树-构建呈现树（框架树）-布局（重排）-绘制等几个步骤。<br>浏览器计算完优先级后，只有后定义的背景图案规则被构建到呈现树上。接下来浏览器会进行重排和绘制，浏览器在绘制时才会请求背景图片规则用到的图片文件。这就是为什么只发出一个HTTP请求的原因。</p><h3 id="使用margin可以做出圆角按钮的原理是什么？"><a href="#使用margin可以做出圆角按钮的原理是什么？" class="headerlink" title="使用margin可以做出圆角按钮的原理是什么？"></a>使用margin可以做出圆角按钮的原理是什么？</h3><p>当不能使用border-radius时,制造1px圆角的小技巧：button中嵌套span，设置span的margin为：”margin:1px -1px”。<br><img src="http://mmbiz.qpic.cn/mmbiz_jpg/btsCOHx9LAMOgCIzMRn1Cw6qKicmGib8GmBBhiagZutJDPPuVJ2jJWO3KZanmcO9QMCcuZI4CiaqcsSZvUVnY18aGw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="image"></p><p>图中红色框为span标签，蓝色框为a标签。当设置span的左右margin为-1px时，其便会在左右各突出1px，造成一种1px圆角的视觉效果。同样的道理，在实现一些古老浏览器下的圆角与底色渐变的按钮时，通常也会利用到多层元素层叠制造视觉误差的原理。</p><h3 id="常见兼容性问题？"><a href="#常见兼容性问题？" class="headerlink" title="常见兼容性问题？"></a>常见兼容性问题？</h3><p>1、png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理。</p><p>2、浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p><p>3、IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p><p>4、浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——<em>display:inline;将其转化为行内属性。(</em>这个符号只有ie6会识别)</p><p>5、渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。<br>css// .bb{ background-color:#f1ee18; .background-color:#00deff\9; +background-color:#a200ff; _background-color:#1e0bd1; } </p><p>6、IE下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性. 解决方法:统一通过getAttribute()获取自定义属性。</p><p>7、IE下,event对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性. * 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p><p>8、Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。</p><p>9、超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}</p><p>10、上下margin重合问题<br>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。<br>解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p><p>11、ie6对png图片格式支持不好(引用一段脚本处理)</p><h3 id="怎样去掉选中时的虚线框？"><a href="#怎样去掉选中时的虚线框？" class="headerlink" title="怎样去掉选中时的虚线框？"></a>怎样去掉选中时的虚线框？</h3><p>利用onfocus=”this.blur();”例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onfocus</span>=<span class="string">"this.blur();"</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="设置图片元素上下垂直居中"><a href="#设置图片元素上下垂直居中" class="headerlink" title="设置图片元素上下垂直居中"></a>设置图片元素上下垂直居中</h3><p>1、diaplay:table-cell（IE6\7不兼容）<br>2、position加margin（IE6不支持）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.center</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">margin</span>: auto;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3、position加transform （ie9以下不支持 transform，手机端表现的比较好）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.center</span> &#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>4、flex;align-items: center;justify-content: center（移动端首选）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrap</span> &#123;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">    <span class="attribute">align-items</span>: center;</div><div class="line">    <span class="attribute">justify-content</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>5、display:flex;margin:auto（移动端首选）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrap</span> &#123;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.center</span> &#123;</div><div class="line">    <span class="attribute">margin</span>: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>6、纯position（适用于所有浏览器）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 方法一：*/</span></div><div class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.center</span> &#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">50px</span>;<span class="comment">/*left=(父元素的宽 - 子元素的宽 ) / 2 */</span></div><div class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;<span class="comment">/*top=(父元素的高 - 子元素的高 ) / 2 */</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/* 方法二：*/</span></div><div class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.center</span> &#123;</div><div class="line">    <span class="attribute">background</span>: green;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;<span class="comment">/*left值固定为50% */</span></div><div class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;<span class="comment">/*top固定为50% */</span></div><div class="line">    <span class="attribute">margin-left</span>:-<span class="number">50px</span>;<span class="comment">/*-（子元素的宽/2） */</span></div><div class="line">　  <span class="attribute">margin-top</span>:-<span class="number">50px</span>;<span class="comment">/*-（子元素的高/2） */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="px-em-rem有什么区别？-为什么通常给font-size-设置的字体为62-5"><a href="#px-em-rem有什么区别？-为什么通常给font-size-设置的字体为62-5" class="headerlink" title="px/em/rem有什么区别？ 为什么通常给font-size 设置的字体为62.5%?"></a>px/em/rem有什么区别？ 为什么通常给font-size 设置的字体为62.5%?</h3><p>相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。<br>1、em的值并不是固定的；<br>2、em会继承父级元素的字体大小。使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。<br>rem是相对于浏览器进行缩放的。1rem默认是16px，在响应式布局中，一个个除来转换成rem，太麻烦，所以重置rem<br>body{font-size=62.5% } 此时1rem = 10px;若是12px则是1.2rem。</p><h3 id="CSS3有哪些新特性？"><a href="#CSS3有哪些新特性？" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h3><p>1、边框：border-radius、box-shadow、border-image<br>2、背景：background-size、background-origin<br>3、文本效果：text-shadow、word-wrap<br>4、字体：@font-face规则<br>5、2D转换：translate()、rotate()、scale()、skew()、matrix()<br>6、3D转换：rotateX()、rotateY()<br>7、过渡：transition：transition-property transition-duration transition-timing-function transition-delay<br>8、动画：@keyframes规则<br>@keyframes myfirst {from{}to{}}//定义动画<br>div{animation: myfirst 5s linear 2s infinite alternate;}</p><h3 id="animation对应的属性"><a href="#animation对应的属性" class="headerlink" title="animation对应的属性"></a>animation对应的属性</h3><blockquote><p>写法：animation: name duration timing-function delay iteration-count direction;</p></blockquote><p>下面是对应的属性的介绍<br>animation-name 规定需要绑定到选择器的 keyframe 名称。<br>animation-duration 规定完成动画所花费的时间，以秒或毫秒计。<br>animation-timing-function 规定动画的速度曲线。<br>animation-delay 规定在动画开始之前的延迟。<br>animation-iteration-count 规定动画应该播放的次数。<br>animation-direction 规定是否应该轮流反向播放动画。</p><h3 id="伪类选择器和伪元素？CSS3中引入的伪类选择器有？CSS3中伪元素有"><a href="#伪类选择器和伪元素？CSS3中引入的伪类选择器有？CSS3中伪元素有" class="headerlink" title="伪类选择器和伪元素？CSS3中引入的伪类选择器有？CSS3中伪元素有?"></a>伪类选择器和伪元素？CSS3中引入的伪类选择器有？CSS3中伪元素有?</h3><p>伪类用一个冒号来表示，而伪元素则用两个冒号来表示。<br><strong>伪类选择器：</strong><br>由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。<br><strong>伪元素选择器：</strong><br>并不是针对真正的元素使用的选择器，而是针对CSS中已经定义好的伪元素使用的选择器；<br><strong>CSS3中引入的伪类选择器：</strong><br>:root()选择器，根选择器，匹配元素E所在文档的根元素。在HTML文档中，根元素始终是<html>。:root选择器等同于<html>元素。</html></html></p><p>:not()选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。</p><p>:empty()选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。</p><p>:target()选择器来对页面某个target元素(该元素的id被当做页面中的超链接来使用)指定样式，该样式只在用户点击了页面中的超链接，并且跳转到target元素后起作用。</p><p>:first-child()选择器表示的是选择父元素的第一个子元素的元素E。简单点理解就是选择元素中的第一个子元素，记住是子元素，而不是后代元素。</p><p>:nth-child()选择某个元素的一个或多个特定的子元素。</p><p>:nth-last-child()从某父元素的最后一个子元素开始计算，来选择特定的元素</p><p>:nth-of-type(n)选择器和:nth-child(n)选择器非常类似，不同的是它只计算父元素中指定的某种类型的子元素。</p><p>:only-child表示的是一个元素是它的父元素的唯一一个子元素。</p><p>:first-line为某个元素的第一行文字使用样式。</p><p>:first-letter 为某个元素中的文字的首字母或第一个字使用样式。</p><p>:before 在某个元素之前插入一些内容。</p><p>:after 在某个元素之后插入一些内容。 </p><p><strong>CSS3中伪元素：</strong></p><blockquote><p>::first-line选择元素的第一行，比如说改变每个段落的第一行文本的样式</p><p>::before和::after这两个主要用来给元素的前面或后面插入内容，这两个常用”content”配合使用，见过最多的就是清除浮动</p><p>::selection用来改变浏览网页选中文的默认效果</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;当margin的值为百分比形式时-为什么浏览器会根据父容器宽度得出计算值？&quot;&gt;&lt;a href=&quot;#当margin的值为百分比形式时-为什么浏览器会根据父容器宽度得出计算值？&quot; class=&quot;headerlink&quot; title=&quot;当margin的值为百分比形式时,为
      
    
    </summary>
    
    
      <category term="HTML" scheme="https://matisha001.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://matisha001.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>变量、作用域和内存问题</title>
    <link href="https://matisha001.github.io/2014/09/20/%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <id>https://matisha001.github.io/2014/09/20/变量、作用域和内存问题/</id>
    <published>2014-09-19T16:34:14.000Z</published>
    <updated>2017-10-05T19:59:13.651Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基本类型和引用类型<br>执行环境<br>垃圾收集</p></blockquote><a id="more"></a><p>按照ECMA-262的定义，Javascript的变量与其他语言的变量有很大区别，其松散类型的本质决定它只是在特定时间用于保存特定值的一个名字而已。</p><h2 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h2><p>Javascript变量可以用来保存两种类型的值：基本类型值和引用类型值。</p><p>基本类型的值源自以下5种基本数据类型：Undefined、Null、Boolean、Number和String。基本类型值和引用类型值具有以下特点：</p><ol><li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；</li><li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；</li><li>引用类型的值是对象，保存在堆内存中；</li><li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的副本；</li><li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；</li><li>确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//基本类型</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = a;</div><div class="line"><span class="built_in">console</span>.log(a)<span class="comment">//5</span></div><div class="line"><span class="built_in">console</span>.log(b)<span class="comment">//5</span></div><div class="line"><span class="comment">//引用类型</span></div><div class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="keyword">var</span> obj2 = obj1;</div><div class="line">obj2.name = <span class="string">"Feng"</span>;</div><div class="line"><span class="built_in">console</span>.log(obj1.name);    <span class="comment">// "Feng"</span></div></pre></td></tr></table></figure><p>所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，<br>这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。<br>以下关于执行环境的几点总结：</p><ol><li>执行环境有全局执行环境（也称全局环境）和函数执行环境之分；</li><li>每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；</li><li>函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，<br>乃至全局环境；</li><li>全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的<br>任何数据；</li><li>变量的执行环境有助于确定应何时释放内存。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> a=<span class="number">1</span>;</div><div class="line">    aa=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//全局函数，前面如果加一个var那就是局部函数了</span></div><div class="line">            a+=<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">　　<span class="function"><span class="keyword">function</span> <span class="title">bb</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        alert(a);</div><div class="line">    &#125;</div><div class="line">   <span class="keyword">return</span> bb;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> f1=f();<span class="comment">//得到返回值bb</span></div><div class="line">f1();<span class="comment">//1</span></div><div class="line">aa();</div><div class="line">f1();<span class="comment">//2</span></div></pre></td></tr></table></figure><p>此题中，aa函数是全局函数（因为前面没有var），可以直接在全局中被调用，并且它能访问f中的局部变量a，为什么？因为函数运行在定义它的环境中，而非调用它的环境中。对于aa来说，定义它的环境是f，调用它的环境是window。全局函数是说函数在任何作用域都可以被调用，也就是说它在全局任何一个角落都可以被访问，在任何角落都是有效的。但是当你在全局任何一个角落调用全局函数时，全局函数还是会回到定义它的作用域中，从那里开始沿着作用域链向上搜索各级执行环境，直到找到所需标识符为止。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基本类型和引用类型&lt;br&gt;执行环境&lt;br&gt;垃圾收集&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Web前端面试题汇总</title>
    <link href="https://matisha001.github.io/2014/07/13/Web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://matisha001.github.io/2014/07/13/Web前端面试题汇总/</id>
    <published>2014-07-13T12:46:25.000Z</published>
    <updated>2017-10-05T19:59:13.614Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何理解HTML结构的语义化？"><a href="#如何理解HTML结构的语义化？" class="headerlink" title="如何理解HTML结构的语义化？"></a>如何理解HTML结构的语义化？</h3><p>所谓标签语义化，就是指标签的含义。语义化的主要目的就是让大家直观的认识标签(markup)和属性(attribute)的用途和作用，对搜索引擎友好，有了良好的结构和语义我们的网页内容便自然容易被搜索引擎抓取，这种符合搜索引擎收索规则的做法，网站的推广便可以省下不少的功夫，而且可维护性更高，因为结构清晰,十分易于阅读。这也是搜索引擎优化SEO重要的一步。</p><a id="more"></a><h3 id="html5有哪些新特性"><a href="#html5有哪些新特性" class="headerlink" title="html5有哪些新特性?"></a>html5有哪些新特性?</h3><p>1、绘画的 canvas 元素<br>2、用于媒介回放的 video 和 audio 元素<br>3、对本地离线存储的更好的支持<br>4、新的特殊内容元素，比如：article、footer、header、nav、section<br>5、新的表单控件，比如：calendar、date、time、email、url、search</p><h3 id="移除了那些元素？"><a href="#移除了那些元素？" class="headerlink" title="移除了那些元素？"></a>移除了那些元素？</h3><p>1、纯表现的元素：basefont，big，center，font, s，strike，tt，u；<br>2、对可用性产生负面影响的元素：frame，frameset，noframes；</p><h3 id="如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？"></a>如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</h3><p>IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式：<br>当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架<br>如何区分html和html5：<br>DOCTYPE声明\新增的结构元素\功能元素</p><h3 id="清除浮动有几种方式-将多个元素设置为同一行"><a href="#清除浮动有几种方式-将多个元素设置为同一行" class="headerlink" title="清除浮动有几种方式?将多个元素设置为同一行?"></a>清除浮动有几种方式?将多个元素设置为同一行?</h3><p>将多个元素设置为同一行：float，inline-block<br>清除浮动的方式：<br>1、父级div定义 height<br>2、结尾处加空div标签 clear:both<br>3、父级div定义 利用:after和:before来在元素内部插入两个元素块，从面达到清除浮动的效果：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.clear</span>&#123;</div><div class="line">    <span class="attribute">zoom</span>:<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">:after</span>&#123;</div><div class="line">    <span class="attribute">content</span>:””;</div><div class="line">    <span class="attribute">clear</span>:both;</div><div class="line">    <span class="attribute">display</span>:block;</div><div class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">overflow</span>:hidden;</div><div class="line">    <span class="attribute">visibility</span>:hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>4、父级div定义 overflow:hidden<br>5、父级div定义 overflow:auto<br>6、父级div 也一起浮动<br>7、父级div定义 display:table</p><h3 id="怪异盒模型box-sizing？弹性盒模型-盒布局"><a href="#怪异盒模型box-sizing？弹性盒模型-盒布局" class="headerlink" title="怪异盒模型box-sizing？弹性盒模型|盒布局?"></a>怪异盒模型box-sizing？弹性盒模型|盒布局?</h3><p> 在标准模式下的盒模型：盒子总宽度/高度=width/height+padding+border+margin<br>在怪异模式下的盒模型下，盒子的总宽度和高度是包含内边距padding和边框border宽度在内的，盒子总宽度/高度=width/height + margin = 内容区宽度/高度 + padding + border + margin;<br>box-sizing有两个值一个是content-box，另一个是border-box。<br>当设置为box-sizing:content-box时，将采用标准模式解析计算；<br>当设置为box-sizing:border-box时，将采用怪异模式解析计算。</p><h3 id="a点击出现框，解决方法"><a href="#a点击出现框，解决方法" class="headerlink" title="a点击出现框，解决方法:"></a>a点击出现框，解决方法:</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">a</span>,<span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>,<span class="selector-tag">a</span><span class="selector-pseudo">:active</span>,<span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>,<span class="selector-tag">a</span><span class="selector-pseudo">:link</span>,<span class="selector-tag">a</span><span class="selector-pseudo">:focus</span>&#123; </div><div class="line">    <span class="attribute">-webkit-tap-highlight-color</span>:<span class="built_in">rgba</span>(0,0,0,0);</div><div class="line">    <span class="attribute">-webkit-tap-highlight-color</span>: transparent;</div><div class="line">    <span class="attribute">outline</span>:none;<span class="attribute">background</span>: none;</div><div class="line">    <span class="attribute">text-decoration</span>: none;<span class="attribute">border</span>:none;</div><div class="line">    <span class="attribute">-webkit-appearance</span>: none; </div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="图片和文字在同一行显示"><a href="#图片和文字在同一行显示" class="headerlink" title="图片和文字在同一行显示?"></a>图片和文字在同一行显示?</h3><p>1、在css中给div添加上“vertical-align:middle”属性。<br>2、分别把图片和文字放入不同的div中，然后用“margin”属性进行定位，就可以使他们显示在同一行。<br>3、把图片设置为背景图片。</p><h3 id="常见兼容性问题？"><a href="#常见兼容性问题？" class="headerlink" title="常见兼容性问题？"></a>常见兼容性问题？</h3><p>1、png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理。</p><p>2、浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p><p>3、IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p><p>4、浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——<em>display:inline;将其转化为行内属性。(</em>这个符号只有ie6会识别)</p><p>5、渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。<br>css// .bb{ background-color:#f1ee18; .background-color:#00deff\9; +background-color:#a200ff; _background-color:#1e0bd1; } </p><p>6、IE下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性. 解决方法:统一通过getAttribute()获取自定义属性。</p><p>7、IE下,event对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性. * 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p><p>8、Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。</p><p>9、超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}</p><p>10、上下margin重合问题<br>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。<br>解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p><p>11、ie6对png图片格式支持不好(引用一段脚本处理)</p><h3 id="怎样去掉选中时的虚线框？"><a href="#怎样去掉选中时的虚线框？" class="headerlink" title="怎样去掉选中时的虚线框？"></a>怎样去掉选中时的虚线框？</h3><p>利用onfocus=”this.blur();”例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onfocus</span>=<span class="string">"this.blur();"</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="设置图片元素上下垂直居中"><a href="#设置图片元素上下垂直居中" class="headerlink" title="设置图片元素上下垂直居中"></a>设置图片元素上下垂直居中</h3><p>1、diaplay:table-cell（IE6\7不兼容）<br>2、position加margin（IE6不支持）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.center</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">margin</span>: auto;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3、position加transform （ie9以下不支持 transform，手机端表现的比较好）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.center</span> &#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>4、flex;align-items: center;justify-content: center（移动端首选）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrap</span> &#123;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">    <span class="attribute">align-items</span>: center;</div><div class="line">    <span class="attribute">justify-content</span>: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>5、display:flex;margin:auto（移动端首选）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrap</span> &#123;</div><div class="line">    <span class="attribute">display</span>: flex;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.center</span> &#123;</div><div class="line">    <span class="attribute">margin</span>: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>6、纯position（适用于所有浏览器）<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 方法一：*/</span></div><div class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.center</span> &#123;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">50px</span>;<span class="comment">/*left=(父元素的宽 - 子元素的宽 ) / 2 */</span></div><div class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;<span class="comment">/*top=(父元素的高 - 子元素的高 ) / 2 */</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/* 方法二：*/</span></div><div class="line"><span class="selector-class">.wrap</span> <span class="selector-class">.center</span> &#123;</div><div class="line">    <span class="attribute">background</span>: green;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</div><div class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;<span class="comment">/*left值固定为50% */</span></div><div class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;<span class="comment">/*top固定为50% */</span></div><div class="line">    <span class="attribute">margin-left</span>:-<span class="number">50px</span>;<span class="comment">/*-（子元素的宽/2） */</span></div><div class="line">　  <span class="attribute">margin-top</span>:-<span class="number">50px</span>;<span class="comment">/*-（子元素的高/2） */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="px-em-rem有什么区别？-为什么通常给font-size-设置的字体为62-5"><a href="#px-em-rem有什么区别？-为什么通常给font-size-设置的字体为62-5" class="headerlink" title="px/em/rem有什么区别？ 为什么通常给font-size 设置的字体为62.5%?"></a>px/em/rem有什么区别？ 为什么通常给font-size 设置的字体为62.5%?</h3><p>相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。<br>1、em的值并不是固定的；<br>2、em会继承父级元素的字体大小。使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。<br>rem是相对于浏览器进行缩放的。1rem默认是16px，在响应式布局中，一个个除来转换成rem，太麻烦，所以重置rem<br>body{font-size=62.5% } 此时1rem = 10px;若是12px则是1.2rem。</p><h3 id="CSS3有哪些新特性？"><a href="#CSS3有哪些新特性？" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h3><p>1、边框：border-radius、box-shadow、border-image<br>2、背景：background-size、background-origin<br>3、文本效果：text-shadow、word-wrap<br>4、字体：@font-face规则<br>5、2D转换：translate()、rotate()、scale()、skew()、matrix()<br>6、3D转换：rotateX()、rotateY()<br>7、过渡：transition：transition-property transition-duration transition-timing-function transition-delay<br>8、动画：@keyframes规则<br>@keyframes myfirst {from{}to{}}//定义动画<br>div{animation: myfirst 5s linear 2s infinite alternate;}</p><h3 id="animation对应的属性"><a href="#animation对应的属性" class="headerlink" title="animation对应的属性"></a>animation对应的属性</h3><blockquote><p>写法：animation: name duration timing-function delay iteration-count direction;</p></blockquote><p>下面是对应的属性的介绍<br>animation-name 规定需要绑定到选择器的 keyframe 名称。<br>animation-duration 规定完成动画所花费的时间，以秒或毫秒计。<br>animation-timing-function 规定动画的速度曲线。<br>animation-delay 规定在动画开始之前的延迟。<br>animation-iteration-count 规定动画应该播放的次数。<br>animation-direction 规定是否应该轮流反向播放动画。</p><h3 id="伪类选择器和伪元素？CSS3中引入的伪类选择器有？CSS3中伪元素有"><a href="#伪类选择器和伪元素？CSS3中引入的伪类选择器有？CSS3中伪元素有" class="headerlink" title="伪类选择器和伪元素？CSS3中引入的伪类选择器有？CSS3中伪元素有?"></a>伪类选择器和伪元素？CSS3中引入的伪类选择器有？CSS3中伪元素有?</h3><p>伪类用一个冒号来表示，而伪元素则用两个冒号来表示。<br><strong>伪类选择器：</strong><br>由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。<br><strong>伪元素选择器：</strong><br>并不是针对真正的元素使用的选择器，而是针对CSS中已经定义好的伪元素使用的选择器；<br><strong>CSS3中引入的伪类选择器：</strong><br>:root()选择器，根选择器，匹配元素E所在文档的根元素。在HTML文档中，根元素始终是<html>。:root选择器等同于<html>元素。</html></html></p><p>:not()选择器称为否定选择器，和jQuery中的:not选择器一模一样，可以选择除某个元素之外的所有元素。</p><p>:empty()选择器表示的就是空。用来选择没有任何内容的元素，这里没有内容指的是一点内容都没有，哪怕是一个空格。</p><p>:target()选择器来对页面某个target元素(该元素的id被当做页面中的超链接来使用)指定样式，该样式只在用户点击了页面中的超链接，并且跳转到target元素后起作用。</p><p>:first-child()选择器表示的是选择父元素的第一个子元素的元素E。简单点理解就是选择元素中的第一个子元素，记住是子元素，而不是后代元素。</p><p>:nth-child()选择某个元素的一个或多个特定的子元素。</p><p>:nth-last-child()从某父元素的最后一个子元素开始计算，来选择特定的元素</p><p>:nth-of-type(n)选择器和:nth-child(n)选择器非常类似，不同的是它只计算父元素中指定的某种类型的子元素。</p><p>:only-child表示的是一个元素是它的父元素的唯一一个子元素。</p><p>:first-line为某个元素的第一行文字使用样式。</p><p>:first-letter 为某个元素中的文字的首字母或第一个字使用样式。</p><p>:before 在某个元素之前插入一些内容。</p><p>:after 在某个元素之后插入一些内容。 </p><p><strong>CSS3中伪元素：</strong></p><blockquote><p>::first-line选择元素的第一行，比如说改变每个段落的第一行文本的样式</p><p>::before和::after这两个主要用来给元素的前面或后面插入内容，这两个常用”content”配合使用，见过最多的就是清除浮动</p><p>::selection用来改变浏览网页选中文的默认效果</p></blockquote><h3 id="简述前端优化的方式"><a href="#简述前端优化的方式" class="headerlink" title="简述前端优化的方式"></a>简述前端优化的方式</h3><p>1、尽量减少HTTP请求次数<br>2、减少DNS查找次数<br>3、避免跳转<br>4、可缓存的AJAX<br>5、推迟加载内容<br>6、预加载<br>7、减少DOM元素数量<br>8、根据域名划分页面内容<br>9、使iframe的数量最小<br>10、不要出现404错误<br>11、使用内容分发网络<br>12、为文件头指定Expires或Cache-Control<br>13、Gzip压缩文件内容<br>14、配置ETag<br>15、尽早刷新输出缓冲<br>16、使用GET来完成AJAX请求<br>17、把样式表置于顶部<br>18、避免使用CSS表达式（Expression）<br>19、使用外部JavaScript和CSS<br>20、削减JavaScript和CSS<br>21、用<link>代替@import<br>22、避免使用滤镜<br>23、把脚本置于页面底部<br>24、剔除重复脚本</p><h3 id="你如何对网站的文件和资源进行优化？"><a href="#你如何对网站的文件和资源进行优化？" class="headerlink" title="你如何对网站的文件和资源进行优化？"></a>你如何对网站的文件和资源进行优化？</h3><blockquote><p>文件合并<br>文件最小化/文件压缩<br>使用CDN托管<br>缓存的使用</p></blockquote><h3 id="为什么利用多个域名来提供网站资源会更有效？"><a href="#为什么利用多个域名来提供网站资源会更有效？" class="headerlink" title="为什么利用多个域名来提供网站资源会更有效？"></a>为什么利用多个域名来提供网站资源会更有效？</h3><p>1、CDN缓存更方便<br>2、突破浏览器并发限制（一般每个域名建立的链接不超过6个）<br>3、Cookieless，节省带宽，尤其是上行带宽一般比下行要慢<br>4、对于UGC的内容和主站隔离，防止不必要的安全问题(上传js窃取主站cookie之类的)。正是这个原因要求用户内容的域名必须不是自己主站的子域名，而是一个完全独立的第三方域名。<br>5、数据做了划分，甚至切到了不同的物理集群，通过子域名来分流比较省事。这个可能被用的不多。<br>PS:关于Cookie的问题，带宽是次要的，安全隔离才是主要的。关于多域名，也不是越多越好，虽然服务器端可以做泛解释，浏览器做dns解释也是耗时间的，而且太多域名，如果要走https的话，还有要多买证书和部署的问题。</p><h3 id="请说出三种减少页面加载时间的方法"><a href="#请说出三种减少页面加载时间的方法" class="headerlink" title="请说出三种减少页面加载时间的方法"></a>请说出三种减少页面加载时间的方法</h3><p>1、优化图片<br>2、图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）<br>3、优化CSS（压缩合并css，如margin-top,margin-left…)<br>4、网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。）<br>5、标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）<br>6、减少http请求（合并文件，合并图片）。</p><h3 id="解释下JavaScript中this是如何工作的"><a href="#解释下JavaScript中this是如何工作的" class="headerlink" title="解释下JavaScript中this是如何工作的"></a>解释下JavaScript中this是如何工作的</h3><p>this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。匿名函数或不处于任何对象中的函数指向window 。</p><p>1、如果是call，apply,with，指定的this是谁，就是谁。<br>2、普通的函数调用，函数被谁调用，this就是谁。</p><h3 id="解释下原型继承的原理"><a href="#解释下原型继承的原理" class="headerlink" title="解释下原型继承的原理"></a>解释下原型继承的原理</h3><p>以下代码展示了JS引擎如何查找属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>(<span class="params">obj,prop</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(prop)) &#123;</div><div class="line">        <span class="keyword">return</span> obj[prop];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj.__proto__!==<span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> getProperty(obj.__proto__,prop);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">undefined</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="http://s10.sinaimg.cn/mw690/001Z3Vflgy71PuAfaMF39" alt="image"></p><h3 id="事件绑定与冒泡机制"><a href="#事件绑定与冒泡机制" class="headerlink" title="事件绑定与冒泡机制"></a>事件绑定与冒泡机制</h3><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><blockquote><p>XMLHttpRequest对象</p></blockquote><h3 id="Jsonp"><a href="#Jsonp" class="headerlink" title="Jsonp"></a>Jsonp</h3><h3 id="一道js基础综合题"><a href="#一道js基础综合题" class="headerlink" title="一道js基础综合题"></a>一道js基础综合题</h3><blockquote><p>此题涉及的知识点众多，包括变量定义提升、this指针指向、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等等。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">1</span>); &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">2</span>);&#125;;</div><div class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">3</span>);&#125;;</div><div class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">4</span>);&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; alert (<span class="number">5</span>);&#125;</div><div class="line"></div><div class="line"><span class="comment">//请写出以下输出结果：</span></div><div class="line">Foo.getName();<span class="comment">//2</span></div><div class="line">getName();<span class="comment">//4</span></div><div class="line">Foo().getName();<span class="comment">//1</span></div><div class="line">getName();<span class="comment">//1</span></div><div class="line"><span class="keyword">new</span> Foo.getName();<span class="comment">//2</span></div><div class="line"><span class="keyword">new</span> Foo().getName();<span class="comment">//3</span></div><div class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();<span class="comment">//3</span></div></pre></td></tr></table></figure><p><a href="http://www.cnblogs.com/xxcanghai/p/5189353.html" target="_blank" rel="external">http://www.cnblogs.com/xxcanghai/p/5189353.html</a></p><h3 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h3><p><strong>三次握手：</strong></p><blockquote><p>第一次握手：建立连接时，客户端A发生SYN包（SYN=j）到服务器B,并进入SYN_SEND状态，等待服务器B确认；<br>第二次握手：服务器B收到SYN包，必须确认客户A的SYN，ACK=j+1,同时自己也发送一个SYN包，SYN=k 即，SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端A收到服务器B的SYN+ACK包,向服务器B发送确认包ACK(ACK=k+1),此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</p></blockquote><p><strong>四次挥手：</strong></p><blockquote><p>客户端A发送一个FIN.用来关闭客户A到服务器B的数据传送(报文段4)；<br>服务器B收到这个FIN. 它发回一个ACK，确认序号为收到的序号+1（报文段5）。和SYN一样，一个FIN将占用一个序号；<br>服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）；<br>客户端A发回ACK报文确认，并将确认序号设置为序号加1（报文段7）。</p></blockquote><h3 id="输入URL到展现页面的全过程"><a href="#输入URL到展现页面的全过程" class="headerlink" title="输入URL到展现页面的全过程"></a>输入URL到展现页面的全过程</h3><p>1、域名解析<br>2、建立TCP连接<br>3、发起HTTP请求<br>4、服务器响应HTTP请求<br>5、浏览器渲染页面</p><h3 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何理解HTML结构的语义化？&quot;&gt;&lt;a href=&quot;#如何理解HTML结构的语义化？&quot; class=&quot;headerlink&quot; title=&quot;如何理解HTML结构的语义化？&quot;&gt;&lt;/a&gt;如何理解HTML结构的语义化？&lt;/h3&gt;&lt;p&gt;所谓标签语义化，就是指标签的含义。语义化的主要目的就是让大家直观的认识标签(markup)和属性(attribute)的用途和作用，对搜索引擎友好，有了良好的结构和语义我们的网页内容便自然容易被搜索引擎抓取，这种符合搜索引擎收索规则的做法，网站的推广便可以省下不少的功夫，而且可维护性更高，因为结构清晰,十分易于阅读。这也是搜索引擎优化SEO重要的一步。&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="https://matisha001.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://matisha001.github.io/tags/CSS/"/>
    
      <category term="javascript" scheme="https://matisha001.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
