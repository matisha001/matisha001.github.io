<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vuex的使用]]></title>
    <url>%2F2016%2F08%2F29%2Fvuex%2F</url>
    <content type="text"></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router的使用]]></title>
    <url>%2F2016%2F08%2F25%2Freact-router%2F</url>
    <content type="text"></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router的使用]]></title>
    <url>%2F2016%2F08%2F25%2Fvue-router%2F</url>
    <content type="text"></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript 6的使用]]></title>
    <url>%2F2016%2F08%2F19%2Fes6%2F</url>
    <content type="text"><![CDATA[作用域块的作用域-let let 定义的变量只能在定义的块中使用 恒量-const const 限制给衡量分配值的动作,不会限制恒量里面的值 不能重复声明 解构解构数组12let [a,b,c] = [1,2,3]console.log(a,b,c) 解构对象12let &#123;a:e,b:f,c:g&#125; = &#123;a:1,b:2,c:3&#125;console.log(e,f,g) 字符串模版字符串123let a =1,b=2let c =` $&#123;a&#125; and $&#123;b&#125;` //注意变量需要用&#123;&#125;包裹起来console.log(c) 带标签的模版字符串 处理字符串内的代码 1234567let a =1,b=2let c = test` $&#123;a&#125; and $&#123;b&#125; \n` //注意变量需要用&#123;&#125;包裹起来console.log(c)function test(strings,...values)&#123; console.log(strings,strings.raw) //模板字符串的每一部分对应的字符 原始字符 console.log(values)//模板字符串的值&#125; 判断字符串是否包含其他字符串1234let a = "test"a.startsWith("a") //注意是starts + Witha.endsWith("a") //注意是ends + Witha.includes("a") //注意是includes 函数默认参数1234function test(a=1,b=2)&#123; console.log(a,b)&#125;test(3,4) 展开操作符1234let a =[1,2,3],b=[0,...a]console.log(a)console.log(...a)console.log(b) 剩余操作符123456function test(a,b,...c)&#123; console.log(a) console.log(b) console.log(c)&#125;test(1,2,3,4,5,6,7) //c 为一个数组 解构参数1234function test(a,b,&#123;c,d&#125;=&#123;&#125;)&#123; console.log(a,b,c,d)&#125;test(1,2,&#123;c:3,d:4&#125;) 函数的name属性123456789let c = function test(a,b)&#123; //函数声明，对应的name属性的值就是函数的名字。&#125;console.log(c.name) //testlet d = function (a,b)&#123; //使用匿名表达式定义的函数，对应的name属性的值就是变量的名字。&#125;console.log(d.name) //d 箭头函数1234567891011let a = b =&gt; b;let a =(b,c) =&gt; &#123; &#125;let a =() =&gt; &#123;&#125;使用babel编译文件babel main.js --watch --out-file index.js 对象对象表达式1234567891011121314let a = 1，b = 2;let c =&#123; a:a, b:b, d: function()&#123; &#125;&#125;let d = &#123; a, b, d()&#123;&#125;&#125; 对象属性1234let a =&#123;&#125;;let d= 'b c'a.b=1;a['b c']=2;//a[d]=2; Object.is() 对比两个值是否相等 12Object.is(NaN,NaN);Object.is(+0,-0) Object.assign() 把对象的值复制到另一个对象里 1234567let a =&#123;&#125;;Object.assign( a,&#123; b:1 &#125;);console.log(a) Object.setPrototypeOf() 设置对象的 prototype 1234567891011121314151617let a =&#123; test()&#123; console.log("1") &#125;&#125;;let b =&#123; test()&#123; console.log("2") &#125;&#125;let c = Object.creat(a);console.log(c.test());//1console.log(getPrototypeOf(c)===a);//trueObject.setPrototypeOf(c,b);console.log(c.test());//2console.log(getPrototypeOf(c)===b);//true proto12345678910111213141516171819let a =&#123; test()&#123; console.log("1") &#125;&#125;;let b =&#123; test()&#123; console.log("2") &#125;&#125;let c = &#123; __proto__:a&#125;console.log(c.test());//1console.log(getPrototypeOf(c)===a);//truec.__proto__ = b;console.log(c.test());//2console.log(getPrototypeOf(c)===b);//true super 重新定义方法覆盖原来的方法1234567891011121314151617let a =&#123; test()&#123; console.log("1") &#125;&#125;;let b =&#123; test()&#123; console.log("2") &#125;&#125;let c = &#123; __proto__:a, test()&#123; return super.test() +"test001" &#125;&#125;console.log(c.test());//1test001 Iterators 迭代器 轮流交换 特点:每次执行都会返回一个对象:{value: xx,done:true/false}。除此之外，Iterators还会有一个next的方法。 每次执行next方法就会返回一个对象{value: xx,done:true/false}。如果没有迭代的东西，next执行以后返回{value: undefined,done:true}。done的值为true表示完成迭代。 1234567891011121314151617function a(b)&#123; let i = 0; return &#123; next()&#123; let done = (i &gt;= b.length); let value =!done ? b[i++]:undefined; return &#123; value, done &#125; &#125; &#125;&#125;let c = a([1,2]);console.log(c.next())console.log(c.next())console.log(c.next()) Generators生成迭代器 123456789101112131415161718function* a()&#123; yield '1'; yield '2';&#125;let b = a();console.log(b.next());console.log(b.next());console.log(b.next());function* c(d)&#123; for(var i=1;i&lt;d.length;i++)&#123; yield d[i]; &#125;&#125;let d =[1,2];console.log(d.next());console.log(d.next());console.log(d.next()); Classes12345678910class A()&#123; constructor(b)&#123; //基于这个类初始化，会自动调取这个方法 this.b = b; &#125; c()&#123; console.log(this.b) &#125;&#125;let d = new A(&quot;1&quot;);d.c(); get 与 set123456789101112131415class A()&#123; constructor()&#123; //基于这个类初始化，会自动调取这个方法 this.f =[]; &#125; get test()&#123; return this.f; &#125; set test(f)&#123; this.f.push(f) &#125;&#125;let d = new A();console.log(d.test = "1");console.log(d.test = "2");console.log(d.test); 静态方法 不需要实例化类，就可以使用的方法。 123456789class A()&#123; constructor(b)&#123; //基于这个类初始化，会自动调取这个方法 this.b = b; &#125; staitc c()&#123; console.log(this.b) &#125;&#125;A.c("1"); 继承12345678910111213141516class A()&#123; constructor(b,c)&#123; this.b = b; this.c = c; &#125; test()&#123; return `$&#123;this.b&#125;,$&#123;this.c&#125;` &#125;&#125;class B extends A&#123; constructor(b,c)&#123; super(b,c); &#125;&#125;let a = new B("1","2");console.log(a.test()); Set 不能包含重复东西的集合 12345678910111213141516let a = new Set();a.add("1");a.add("2");a.add("3");console.log(a);a.add("1");//没有变化console.log(a.size)//项目个数console.log(a.has('1'))//判断是否存在项目a.delete('2')//删除项目console.log(a);a.forEach(a =&gt; &#123; //循环处理Set里面的项目 console.log(a)&#125;)a.clear()//清空Set()console.log(a); Map 12345678910111213141516let a = new Map();let b =&#123;&#125;,c =function () &#123;&#125;,d = "1";a.set(b,"1");a.set(c,"2");a.set(d,"3");console.log(a);console.log(a.size)//项目个数console.log(a.get(b))//项目对应的值a.delete(d)//删除项目console.log(a);console.log(a.has(d))//判断是否存在项目a.forEach((value,key) =&gt; &#123; //循环处理Map里面的项目 console.log(`$&#123;value&#125; = $&#123;key&#125;`);&#125;)a.clear()//清空Map()console.log(a); Module123456789101112131415//test1.jsexport let a = "1";//test2.jslet a = 1;let b = 2;function c (d,e)&#123; console.log(`$&#123;d&#125;,$&#123;e&#125;`)&#125; export &#123;a,b,c&#125;;//test3.jsimport &#123;a,b&#125; from "./test2.js"console.log(a,b)//test4.jsimport * as c from "./test2.js"console.log(c.a,c.b); 重命名12345678910//test1.jslet a = 1;let b = 2;function c (d,e)&#123; console.log(`$&#123;d&#125;,$&#123;e&#125;`)&#125; export &#123;a,b,c as test&#125;;//test2.jsimport &#123;a,b as t&#125; from "./test1.js"console.log(a,t) 默认 导入默认不需要{}123456789101112//test1.jsexport default function c (d,e)&#123; console.log(`$&#123;d&#125;,$&#123;e&#125;`)&#125; //test2.jsfunction c (d,e)&#123; console.log(`$&#123;d&#125;,$&#123;e&#125;`)&#125; export &#123; c as default&#125;;//test3.jsimport test from "./test1.js"test();]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-resource的使用]]></title>
    <url>%2F2016%2F08%2F19%2Fvue-resource%2F</url>
    <content type="text"></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的基础]]></title>
    <url>%2F2016%2F08%2F19%2Fvue%2F</url>
    <content type="text"></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用gulp配置react]]></title>
    <url>%2F2016%2F02%2F10%2Fgulp%20for%20react%2F</url>
    <content type="text"><![CDATA[环境搭建安装依赖 npm i -g gulp npm i react –save npm i –save-dev gulp gulp-browserify gulp-concat gulp-react lodash reactify bower init bower install bootstrap –save 配置gulpfile.js12345678910111213141516171819202122232425262728293031323334353637var gulp = require('gulp'),//运行任务 connect = require('gulp-connect'),//运行connect服务器 browserify = require('gulp-browserify'),//将组件拼接在一起,使浏览器代码也可以使用require来构建 concat = require('gulp-concat'),//将所有文件拼在一起 port = process.env.port || 5000;gulp.task('browserify',function()&#123; gulp.src('./app/js/main.js') .pipe(browserify(&#123; transform: 'reactify', &#125;)) .pipe(gulp.dest('./dist/js'))&#125;);// live reload gulp.task('connect',function()&#123; connect.server(&#123; // root:'./', port: port, livereload: true, &#125;)&#125;)// 刷新js gulp.task('js',function()&#123; gulp.src('./dist/**/*.js') .pipe( connect.reload() )&#125;)// 刷新html gulp.task('html',function()&#123; gulp.src('./app/**/*.html') .pipe( connect.reload() )&#125;);gulp.task('watch',function()&#123; gulp.watch('./dist/**/*.js',['js']); gulp.watch('./app/**/*.html',['html']); gulp.watch('./app/js/**/*.js',['browserify']);&#125;)gulp.task('default',['browserify']);gulp.task('serve',['browserify','connect','watch']);]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux的使用]]></title>
    <url>%2F2016%2F01%2F19%2Fredux%2F</url>
    <content type="text"></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react的基础]]></title>
    <url>%2F2016%2F01%2F19%2Freact%2F</url>
    <content type="text"><![CDATA[React语法React.render123456var test = React.render( &lt;Component/&gt;, document.getElementById('app'), callback)console.log(test) React.render返回的是一个在当前作用域上的一个对象 React.createClass1234567891011121314151617181920212223242526var Component = React.createClass(&#123; getInitialState:function()&#123; //state初始状态 &#125;, propTypes:&#123; //验证props格式是否正确 &#125;, getDefaultProps:function()&#123; //props初始参数 &#125;, componentWillMount:function()&#123; //组件将要被装载 &#125;, componentDidMount:function()&#123; //组件已经被装载 &#125;, componentWillUnmount: function()&#123; //组件将要被卸载 React.unmountComponentAtNode( document.getElementById('app') );//删除react节点 &#125;, render:function()&#123; return ( &lt;div&gt;test&lt;/div&gt; ) &#125;&#125;); React生命周期 react生命周期分三个阶段装载、更新、卸载 装载constructor() react后期版本 getDefaultProps() props初始参数 getInitialState() state初始状态 componentWillMount() 组件将要被装载 改变state时，不会二次渲染 render()componentDidMount() 组件已经被装载 改变state时，会二次渲染 可以通过this.getDOMNode()获取dom 进行ajax操作,获取值改变state 123componentDidMount:function()&#123; console.log(this.getDOMNode() );&#125;, 更新 第一次加载组件的时候不会执行更新阶段。 componentWillReceiveProps() 子组件将要获取props,根据props来判断state是否需要更新,确保只渲染一次 123componentWillReceiveProps:function(nextProps)&#123;&#125;, shouldComponentUpdate() 是否允许更新 可以设置更新的限制 123shouldComponentUpdate:function(nextProp,nextState)&#123; return true;&#125;, componentWillUpdate() 组件将要被更新 shouldComponentUpdate返回为true时，不可以取消更新 123componentWillUpdate:function(nextProp,nextState)&#123;&#125;, render()componentDidUpdate() 组件已经被更新 123componentDidUpdate:function()&#123;&#125;, 卸载componentWillUnmount() 组件将要被卸载 用于一些组件取消事件监听或者清除定时器 123456789101112131415161718192021222324componentWillMount:function()&#123; var self = this; this.timer = setInterval(function()&#123; self.setState(&#123; count: self.state.count + 1, &#125;) &#125;,1000);&#125;,componentWillUnmount: function()&#123; alert('you are tring to kill me !! ') clearInterval(this.timer);&#125;,killMySelf: function()&#123; React.unmountComponentAtNode( document.getElementById('app') );&#125;,render:function()&#123; return ( &lt;div&gt; &lt;h1 &gt; 计数： &#123;this.state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.killMySelf&#125;&gt;卸载掉这个组件&lt;/button&gt; &lt;Submessage/&gt; &lt;/div&gt; )&#125;, React组件组件嵌套 react组件的嵌套必须在外面用一个标签包裹起来 父组件在传递一个数组的时候,子组件必须要有一个key 12345678910111213141516var Components = React.createClass(&#123; render:function()&#123; var subComponents = []; for(var i=0; i&lt;10; i++)&#123; subComponents.push( &lt;Component key=&#123;'subMsg'+i&#125;/&gt; ) &#125; return ( &lt;div&gt; &lt;h1&gt;你好世界！！！&lt;/h1&gt; &#123;subComponents&#125; &lt;/div&gt; ) &#125;&#125;); 组件状态state1234567891011121314151617var Component = React.createClass(&#123; getInitialState:function()&#123; //获取初始状态 &#125;, handleClick: function()&#123; this.setState(&#123; Count: 1, &#125;) &#125;, render:function()&#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; test &lt;/div&gt; ) &#125;&#125;); 不要使用this.state来改变state的状态，要用this.setState({})来改变state的状态.调用setState,react将重新render一下。 如果非要使用this.state来改变state的状态，需要调用forceUpdate() 组件通信props this.props.children 用于表示闭合标签组件之间的内容 123456789var Component = React.createClass(&#123; render:function()&#123; return ( &lt;div&gt; &lt;Submessage &#123;...this.props &#125; messages=&#123;this.state.subMessages&#125; /&gt; &lt;/div&gt; ) &#125;&#125;); 123456789101112131415161718192021var Submessage = React.createClass(&#123; propTypes:&#123; //验证props格式是否正确 messages: React.PropTypes.array.isRequired, &#125;, getDefaultProps:function()&#123; //props初始参数 &#125;, render:function()&#123; var msgs = []; this.props.messages.forEach(function(msg,index)&#123; msgs.push( &lt;p&gt;&#123;msg&#125;&lt;/p&gt; ) &#125;); return ( &lt;div&gt;&#123;msgs&#125;&lt;/div&gt; ) &#125;&#125;); PropTypes种类有 bool、array、func、number、object、string等 组件指向ref1234567891011121314151617181920212223var Component = React.createClass(&#123; handleClick: function(e)&#123; e.preventDefault(); //获取原生dom对象 console.log(this.refs.mytest.getDOMNode()); console.log(React.findDOMNode(this.refs.mytest)); this.refs.mytest.saySomething(); &#125;, render:function()&#123; return ( &lt;div&gt; &lt;Submessage ref="mytest" messages=&#123;this.state.subMessages&#125; /&gt; &lt;input ref=&#123; function(comp)&#123; React.findDOMNode(comp).focus() &#125; &#125; /&gt;test &lt;/div&gt; ) &#125;&#125;); 12345678910var Submessage = React.createClass(&#123; saySomething：function()&#123; alert("111") &#125;, render:function()&#123; return ( &lt;div onChange=&#123;this.props.handleClick&#125;&gt;&#123;msgs&#125;&lt;/div&gt; ) &#125;&#125;); ref指的是react对象,在子组件中定义其他方法,ref也可以实现调用。 ref是字符串,实际上也可以是函数 React事件1234567891011121314151617var Component = React.createClass(&#123; handleClick: function(e)&#123; e.preventDefault(); this.setState(&#123; Count: 1, &#125;); console.log(e.nativeEvent);//浏览器自带的event console.log(e.target);//封装的event &#125;, render:function()&#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; test &lt;/div&gt; ) &#125;&#125;); mixins mixins和组件的生命周期是密切相关的,定义mixins目的就是让组件共用一些逻辑。 React双向数据流 react 采用的是单向数据流。 react-with-addons.js 实现react双向数据流,需要mixins 1234567891011var Component = React.createClass(&#123; mixins: [ React.addons.LinkedStateMixin ], render:function()&#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.message&#125;&lt;/h1&gt; &lt;input type=&quot;text&quot; valueLink=&#123;this.linkState(&apos;message&apos;)&#125; /&gt; &lt;/div&gt; ) &#125;&#125;); mixins开发12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var stateRecordMixin = &#123; componentWillMount:function()&#123; this.oldStates = []; &#125;, componentWillUpdate: function(nextProp,nextState)&#123; this.oldStates.push(nextState); &#125;, previousState:function()&#123; var index = this.oldStates.length -1; return index == -1 ? &#123;&#125; : this.oldStates[index]; &#125;&#125;var MessageBox = React.createClass(&#123; mixins: [stateRecordMixin], getInitialState:function()&#123; return &#123; count: 0, &#125; &#125;, doUpdate:function()&#123; this.setState(&#123; count: this.state.count + 1, &#125;); alert(this.previousState().count) &#125;, render:function()&#123; return ( &lt;div&gt; &lt;h1 &gt; 计数： &#123;this.state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.doUpdate&#125;&gt;手动更新一下组件&lt;/button&gt; &lt;Submessage count=&#123;this.state.count&#125;/&gt; &lt;/div&gt; ) &#125;&#125;);var Submessage = React.createClass(&#123; mixins: [stateRecordMixin], getInitialState:function()&#123; return &#123; count: 0, &#125; &#125;, componentWillReceiveProps:function(nextProp)&#123; this.setState(&#123; count: this.props.count *2, &#125;) &#125;, render:function()&#123; console.log(this.previousState().count ) return ( &lt;h3&gt;当前子组件的计数是：&#123;this.state.count&#125;&lt;/h3&gt; ) &#125;&#125;);]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack的使用]]></title>
    <url>%2F2015%2F03%2F19%2Fwebpack%2F</url>
    <content type="text"><![CDATA[安装webpack12npm i webpack --gwebpack --help 使用webpack创建项目123npm init npm i webpack webpack enter.js bundle.js 打包生成的bundle.js包含webpack本身需要的一些东西。 webpack提供了全局命令进行编译,也提供了通过node命令进行编译。 模块依赖123//main.jsvar test=require('./test');console.log(test) 12//test.jsmodule.exports="matisha001" loader转换器 loader转换器是将资源从一种形式转化为另一种形式，最总转化为js。 123//常见的转换器css-loader、style-loader等require('style!css!./style.css'); 配置文件 默认的配置文件为webpack.config.js1输入 webpack 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//webpack.config.jsmodule.exports = &#123; entry:'./main.js',//入口文件 output:&#123;//生成文件 path:__dirname,//输出文件路径 publicPath:__dirname,//请求静态资源绝对路径 filename:'[name].js' &#125;, resolve: &#123; //模块相关配置 extensions: ['', '.js', '.vue'],//自动补全文件后缀 fallback: [path.join(__dirname, '../node_modules')],//找不到模块时，在node_modules下查找 alias: &#123;//路径别名缩短路径长度 '@': path.resolve(__dirname, '../src'), &#125; &#125;, resolveLoader: &#123;//找不到模块时，在node_modules下查找 fallback: [path.join(__dirname, '../node_modules')] &#125;, devtool:'source-map',//生成source-map文件 module:&#123; //要使用的模块 preLoaders: [ &#123; test: /\.vue$/, loader: 'eslint', include: projectRoot, //编译目录 exclude: /node_modules/ //排除目录 &#125;, &#123; test: /\.js$/, loader: 'eslint', include: projectRoot, exclude: /node_modules/ &#125; ], loaders: [ &#123; test: /\.vue$/, loader: 'vue' &#125;, &#123; test: /\.js$/, loader: 'babel', include: projectRoot, exclude: /node_modules/ &#125;, &#123; test: /\.json$/, loader: 'json' &#125;, &#123; test: /\.html$/, loader: 'vue-html' &#125;, &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url', query: &#123; limit: 10000, //小于10000生成base64，大于10000生成单独的文件 name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: 'url', query: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125; ] &#125;, eslint: &#123; //eslint错误信息友好提示 formatter: require('eslint-friendly-formatter') &#125;, vue: &#123; //vue文件中css处理loaders loaders: utils.cssLoaders() &#125;&#125;; 调试代码 source-map 生成source-map文件1webpack --devtool source-map 123//test.jsdebugger; //代码打断点module.exports="matisha001" babel转换12//安装babel依赖npm i babel-loader babel-core babel-preset-es2015 --save-dev 1234//创建.babelrc配置文件&#123; "presets":["es2015"] //设置babel预设&#125; 123//main.jsimport name from './name';export default name; webpack插件webpack-dev-server提供开发服务器、页面刷新、模块热替换(只替换有变化的内容，不需要刷新整个页面)。 123npm i webpack-dev-server --gnpm i webpack-dev-server --save-devwebpack-dev-server --inline --hot webpack-merge 合并配置文件 http-proxy-middleware http协议代理中间件,可以代理转发api html-webpack-plugin webpack操作html的插件,将打包生成js、css插入到html模板里 eslint-friendly-formatter eslint错误信息友好提示 extract-text-webpack-plugin webpack扩展插件 express node框架,用于启动webserver webpack-dev-middleware express和weppack开发环境中间件 将编译好的文件放在内存中 当前目录没有该文件 webpack-hot-middleware express和webpack 热更新配合的中间件 创建react项目123//安装依赖npm i babel-core babel-preset-es2015 babel-preset-react webpack webpack-dev-server babel-loader react-hot-loader --save-devnpm i react react-dom --save 1234567891011121314151617181920//webpack.config.jsmodule.exports = &#123; entry:'./main.js',//入口文件 output:&#123;//生成文件 path:__dirname, filename:'bundle.js' &#125;, devtool:'source-map',//生成source-map文件 module:&#123; //要使用的模块 loaders:[ &#123; test:[/\.js$/,/\.jsx?$/], exclude:/(node_modules)/, loader:'react-hot!babel' &#125;, &#123;test:/\.css$/,loader:'style!css'&#125; ] &#125;&#125;; 1234//创建.babelrc配置文件&#123; "presets":["es2015","react"] //设置babel预设&#125; 创建vue项目cssloaders配置12345678910111213141516171819202122232425262728293031exports.cssLoaders = function (options) &#123; options = options || &#123;&#125; function generateLoaders (loaders) &#123; var sourceLoader = loaders.map(function (loader) &#123; var extraParamChar if (/\?/.test(loader)) &#123; loader = loader.replace(/\?/, '-loader?') extraParamChar = '&amp;' &#125; else &#123; loader = loader + '-loader' extraParamChar = '?' &#125; return loader + (options.sourceMap ? extraParamChar + 'sourceMap' : '') &#125;).join('!') if (options.extract) &#123; return ExtractTextPlugin.extract('vue-style-loader', sourceLoader) &#125; else &#123; return ['vue-style-loader', sourceLoader].join('!') &#125; &#125; return &#123; css: generateLoaders(['css']), postcss: generateLoaders(['css']), less: generateLoaders(['css', 'less']), sass: generateLoaders(['css', 'sass?indentedSyntax']), scss: generateLoaders(['css', 'sass']), stylus: generateLoaders(['css', 'stylus']), styl: generateLoaders(['css', 'stylus']) &#125;&#125; styleLoaders配置 对独立的css及其预处理文件进行编译 123456789101112exports.styleLoaders = function (options) &#123; var output = [] var loaders = exports.cssLoaders(options) for (var extension in loaders) &#123; var loader = loaders[extension] output.push(&#123; test: new RegExp('\\.' + extension + '$'), loader: loader &#125;) &#125; return output&#125; wepack2的使用 暂空 webpack3的使用 暂空 vue-cli webpack模板配置分析vue-cli的webpack模板项目配置文件分析 vue-cli proxytable 配置npm模块之http-proxy-middleware使用教程 http-proxy-middleware Nodejs为代理npm设置代理 gulp-connect-proxy和http-proxy-middleware代理 node+express+http-proxy-middleware代理转发 HTTP代理模块（HTTP Proxy）]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1像素边框]]></title>
    <url>%2F2014%2F08%2F29%2Fborder-1px%2F</url>
    <content type="text"></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
</search>
