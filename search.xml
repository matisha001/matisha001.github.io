<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue基础]]></title>
    <url>%2F2016%2F08%2F19%2Fvue%2F</url>
    <content type="text"></content>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react基础]]></title>
    <url>%2F2016%2F01%2F19%2Freact%2F</url>
    <content type="text"><![CDATA[React语法React.render123456var test = React.render( &lt;Component/&gt;, document.getElementById('app'), callback)console.log(test) React.render返回的是一个在当前作用域上的一个对象 React.createClass1234567891011121314151617181920212223242526var Component = React.createClass(&#123; getInitialState:function()&#123; //state初始状态 &#125;, propTypes:&#123; //验证props格式是否正确 &#125;, getDefaultProps:function()&#123; //props初始参数 &#125;, componentWillMount:function()&#123; //组件将要被装载 &#125;, componentDidMount:function()&#123; //组件已经被装载 &#125;, componentWillUnmount: function()&#123; //组件将要被卸载 React.unmountComponentAtNode( document.getElementById('app') );//删除react节点 &#125;, render:function()&#123; return ( &lt;div&gt;test&lt;/div&gt; ) &#125;&#125;); React生命周期 react生命周期分三个阶段装载、更新、卸载 装载constructor() react后期版本 getDefaultProps() props初始参数 getInitialState() state初始状态 componentWillMount() 组件将要被装载 改变state时，不会二次渲染 render()componentDidMount() 组件已经被装载 改变state时，会二次渲染 可以通过this.getDOMNode()获取dom 进行ajax操作,获取值改变state 123componentDidMount:function()&#123; console.log(this.getDOMNode() );&#125;, 更新 第一次加载组件的时候不会执行更新阶段。 componentWillReceiveProps() 子组件将要获取props,根据props来判断state是否需要更新,确保只渲染一次 123componentWillReceiveProps:function(nextProps)&#123;&#125;, shouldComponentUpdate() 是否允许更新 可以设置更新的限制 123shouldComponentUpdate:function(nextProp,nextState)&#123; return true;&#125;, componentWillUpdate() 组件将要被更新 shouldComponentUpdate返回为true时，不可以取消更新 123componentWillUpdate:function(nextProp,nextState)&#123;&#125;, render()componentDidUpdate() 组件已经被更新 123componentDidUpdate:function()&#123;&#125;, 卸载componentWillUnmount() 组件将要被卸载 用于一些组件取消事件监听或者清除定时器 123456789101112131415161718192021222324componentWillMount:function()&#123; var self = this; this.timer = setInterval(function()&#123; self.setState(&#123; count: self.state.count + 1, &#125;) &#125;,1000);&#125;,componentWillUnmount: function()&#123; alert('you are tring to kill me !! ') clearInterval(this.timer);&#125;,killMySelf: function()&#123; React.unmountComponentAtNode( document.getElementById('app') );&#125;,render:function()&#123; return ( &lt;div&gt; &lt;h1 &gt; 计数： &#123;this.state.count&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.killMySelf&#125;&gt;卸载掉这个组件&lt;/button&gt; &lt;Submessage/&gt; &lt;/div&gt; )&#125;, React组件组件嵌套 react组件的嵌套必须在外面用一个标签包裹起来 父组件在传递一个数组的时候,子组件必须要有一个key 12345678910111213141516var Components = React.createClass(&#123; render:function()&#123; var subComponents = []; for(var i=0; i&lt;10; i++)&#123; subComponents.push( &lt;Component key=&#123;'subMsg'+i&#125;/&gt; ) &#125; return ( &lt;div&gt; &lt;h1&gt;你好世界！！！&lt;/h1&gt; &#123;subComponents&#125; &lt;/div&gt; ) &#125;&#125;); 组件状态state1234567891011121314151617var Component = React.createClass(&#123; getInitialState:function()&#123; //获取初始状态 &#125;, handleClick: function()&#123; this.setState(&#123; Count: 1, &#125;) &#125;, render:function()&#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; test &lt;/div&gt; ) &#125;&#125;); 不要使用this.state来改变state的状态，要用this.setState({})来改变state的状态.调用setState,react将重新render一下。 如果非要使用this.state来改变state的状态，需要调用forceUpdate() 组件通信props123456789var Component = React.createClass(&#123; render:function()&#123; return ( &lt;div&gt; &lt;Submessage &#123;...this.props &#125; messages=&#123;this.state.subMessages&#125; /&gt; &lt;/div&gt; ) &#125;&#125;); 123456789101112131415161718192021var Submessage = React.createClass(&#123; propTypes:&#123; //验证props格式是否正确 messages: React.PropTypes.array.isRequired, &#125;, getDefaultProps:function()&#123; //props初始参数 &#125;, render:function()&#123; var msgs = []; this.props.messages.forEach(function(msg,index)&#123; msgs.push( &lt;p&gt;&#123;msg&#125;&lt;/p&gt; ) &#125;); return ( &lt;div&gt;&#123;msgs&#125;&lt;/div&gt; ) &#125;&#125;); PropTypes种类有 bool、array、func、number、object、string等 组件指向ref1234567891011121314151617181920212223var Component = React.createClass(&#123; handleClick: function(e)&#123; e.preventDefault(); //获取原生dom对象 console.log(this.refs.mytest.getDOMNode()); console.log(React.findDOMNode(this.refs.mytest)); this.refs.mytest.saySomething(); &#125;, render:function()&#123; return ( &lt;div&gt; &lt;Submessage ref="mytest" messages=&#123;this.state.subMessages&#125; /&gt; &lt;input ref=&#123; function(comp)&#123; React.findDOMNode(comp).focus() &#125; &#125; /&gt;test &lt;/div&gt; ) &#125;&#125;); 12345678910var Submessage = React.createClass(&#123; saySomething：function()&#123; alert("111") &#125;, render:function()&#123; return ( &lt;div onChange=&#123;this.props.handleClick&#125;&gt;&#123;msgs&#125;&lt;/div&gt; ) &#125;&#125;); ref指的是react对象,在子组件中定义其他方法,ref也可以实现调用。 ref是字符串,实际上也可以是函数 React事件1234567891011121314151617var Component = React.createClass(&#123; handleClick: function(e)&#123; e.preventDefault(); this.setState(&#123; Count: 1, &#125;); console.log(e.nativeEvent);//浏览器自带的event console.log(e.target);//封装的event &#125;, render:function()&#123; return ( &lt;div onClick=&#123;this.handleClick&#125;&gt; test &lt;/div&gt; ) &#125;&#125;); React双向数据流 react 采用的是单向数据流。 react-with-addons.js 实现react双向数据流,需要mixins 1234567891011var Component = React.createClass(&#123; mixins: [ React.addons.LinkedStateMixin ], render:function()&#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.message&#125;&lt;/h1&gt; &lt;input type="text" valueLink=&#123;this.linkState('message')&#125; /&gt; &lt;/div&gt; ) &#125;&#125;);]]></content>
      <tags>
        <tag>js</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack的使用]]></title>
    <url>%2F2015%2F03%2F19%2Fwebpack%2F</url>
    <content type="text"><![CDATA[安装webpack12npm i webpack --gwebpack --help 使用webpack创建项目123npm init npm i webpackwebpack enter.js bundle.js 打包生成的bundle.js包含webpack本身需要的一些东西。 模块依赖123//main.jsvar test=require('./test');console.log(test) 12//test.jsmodule.exports="matisha001" loader转换器 loader转换器是将资源从一种形式转化为另一种形式，最总转化为js。 123//常见的转换器css-loader、style-loader等require('style!css!./style.css'); 配置文件默认的配置文件为webpack.config.js1输入 webpack 123456789101112131415//webpack.config.jsmodule.exports = &#123; entry:'./main.js',//入口文件 output:&#123;//生成文件 path:__dirname, filename:'bundle.js' &#125;, devtool:'source-map',//生成source-map文件 module:&#123; //要使用的模块 loaders:[ &#123;test:/\.js$/,loader:'babel'&#125;, &#123;test:/\.css$/,loader:'style!css'&#125; ] &#125;&#125;; 调试代码 source-map生成source-map文件1webpack --devtool source-map 123//test.jsdebugger; //代码打断点module.exports="matisha001" babel转换12//安装babel依赖npm i babel-loader babel-core babel-preset-es2015 --save-dev 1234//创建.babelrc配置文件&#123; "presets":["es2015"] //设置babel预设&#125; 123//main.jsimport name from './name';export default name; webpack插件webpack-dev-server提供开发服务器、页面刷新、模块热替换(只替换有变化的内容，不需要刷新整个页面)。 123npm i webpack-dev-server --gnpm i webpack-dev-server --save-devwebpack-dev-server --inline --hot 创建react项目123//安装依赖npm i babel-core babel-preset-es2015 babel-preset-react webpack webpack-dev-server babel-loader react-hot-loader --save-devnpm i react react-dom --save 1234567891011121314151617181920//webpack.config.jsmodule.exports = &#123; entry:'./main.js',//入口文件 output:&#123;//生成文件 path:__dirname, filename:'bundle.js' &#125;, devtool:'source-map',//生成source-map文件 module:&#123; //要使用的模块 loaders:[ &#123; test:[/\.js$/,/\.jsx?$/], exclude:/(node_modules)/, loader:'react-hot!babel' &#125;, &#123;test:/\.css$/,loader:'style!css'&#125; ] &#125;&#125;; 1234//创建.babelrc配置文件&#123; "presets":["es2015","react"] //设置babel预设&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
